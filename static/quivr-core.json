{
    "ANKIConfig": {
        "GIT_URL": "https://github.com/QuivrHQ/quivr/blob/main/"
    },
    "quivr_core__quivr_rag__QuivrQARAG": {
        "label": "QuivrQARAG",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 47,
        "endLineNo": 234,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L47-L234&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown \n\n**[Quick Summary]**\n\nThis function (`answer`) is designed to process a user's question, along with a history of past conversations and a list of relevant documents, and generate a response using a pre-trained language model connected to a retriever-augmented generation (RAG) system. The purpose of the code is to enable a chatbot-like system capable of  answering questions in a comprehensive and context-aware manner.\n\n**[Inputs]**\n\n* `question`: The user's query or question posed to the system.\n* `history`: A record of previous interactions between the user and the system, containing both user messages and the system's generated responses.\n* `list_files`: A collection of documents (likely text-based) that the system can use as a knowledge base to inform its answer.\n* `metadata`: Additional information about the context of the query, which can be used to fine-tune the model's response.\n\n**[Output]**\n\n*  `ParsedRAGResponse`:  A structured response object containing the system's generated answer, potentially including information about the sources used to formulate the response. \n\n\n"
    },
    "quivr_core__chat_llm__ChatLLM": {
        "label": "ChatLLM",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 23,
        "endLineNo": 138,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L23-L138&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code defines a class for interacting with a large language model (LLM) to answer questions based on a conversation history. It filters the history, builds a prompt, and sends the question and filtered history to the LLM for a response. \n\nThis code likely serves as part of a conversational AI system. It allows users to ask questions and receive answers that are contextually relevant to past interactions.\n\n\n## Inputs\n\n*  `question: str`: The user's question.\n*  `history: ChatHistory | None`: Previous conversation history (optional).  \n\n## Output\n\n*  `ParsedRAGResponse`: A structure containing the LLM's response and metadata.\n*  `AsyncGenerator[ParsedRAGChunkResponse, ParsedRAGChunkResponse]`: An asynchronous generator yielding chunks of the LLM's response. \n\n\n"
    },
    "quivr_core__quivr_rag__QuivrQARAG__answer_astream": {
        "label": "answer_astream",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 165,
        "endLineNo": 234,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L165-L234&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Analysis\n\n**[Quick summary]**\n\nThis asynchronous function processes a user question and a history of past conversations using a RAG (Retrieval Augmented Generation) model. It breaks down the response into smaller chunks, potentially with source information, and yields each chunk as it's generated.\n\n**[Inputs]**\n\n* `question`: The user's query.\n* `history`:  A record of previous conversations.\n* `list_files`: A list of relevant documents used by the RAG model for retrieval.\n* `metadata`: Additional information about the request (e.g., user context).\n\n**[Output]**\n\n* An asynchronous generator yielding `ParsedRAGChunkResponse` objects:\n    * Each object contains a portion of the RAG model's response (`answer`).\n\n*  The last yielded chunk includes metadata about the sources used and a `last_chunk=True` flag. \n\n\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint": {
        "label": "LLMEndpoint",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 14,
        "endLineNo": 71,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L14-L71&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis Python class (`BaseOpenAIEndpoint`) acts as a foundation for interacting with different OpenAI models (ChatGPT, Azure OpenAI). It handles configuration, model initialization, and basic information retrieval while offering flexibility for function calling support based on the model. \n\nThe overall purpose of the code is to create a reusable and adaptable interface for working with OpenAI's language models.\n\n## Inputs\n\n* `llm_config: LLMEndpointConfig`: A configuration object specifying the OpenAI model to use (e.g., \"gpt-3.5-turbo\"), API key, base URL, and other parameters.\n* `llm: BaseChatModel`: An instance of a ChatModel class (not defined here) representing the OpenAI model itself.\n\n## Output\n\n*  An instance of `BaseOpenAIEndpoint` initialized with the given configuration and model.\n*  The `get_config` method returns the `llm_config` object.\n*  The `supports_func_calling` method returns a boolean indicating if the model supports function calling.\n*  The `info` method returns an `LLMInfo` object containing details about the model, endpoint, and function calling capabilities.\n\n\n\n"
    },
    "quivr_core__processor__implementations__default___build_processor": {
        "label": "_build_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 41,
        "endLineNo": 94,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L41-L94&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function dynamically creates a class (`_Processor`) that inherits from a base processor class (`ProcessorInit`). This class is designed to load and split documents based on user-specified parameters and a pre-defined tokenizer. Its purpose is to create a flexible pipeline for processing text documents. \n\n## Inputs\n\n* `cls_name`:  A string representing the name of the new class to be created.\n* `load_cls`: A class type used to load documents (e.g., a custom document loader class).\n* `cls_extensions`: A list of file extensions or strings specifying the types of documents this processor can handle.\n\n## Output\n\n*  A new class (`_Processor`) that:\n    * Inherits from `ProcessorInit`.\n    *  Can load documents using the specified `load_cls`.\n    * Splits documents into chunks using a tokenization-based character splitter. \n    * Stores metadata about the processed documents."
    },
    "quivr_core__processor__implementations__tika_processor__TikaProcessor": {
        "label": "TikaProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/tika_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/tika_processor.py",
        "lineNo": 16,
        "endLineNo": 66,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Ftika_processor.py%23L16-L66&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## [Quick Summary]\n\nThis Python function processes a given QuivrFile, sending its contents to a Tika server for extraction. The extracted text is then split into smaller chunks using a specified text splitter configured with  `chunk_size` and `chunk_overlap`. The goal is to break down long documents into manageable pieces for processing or analysis.\n\n\n## [Inputs]\n\n* `file`: A QuivrFile object presumably representing a file to be processed.\n* `tika_url`:  A URL pointing to a running Tika server.\n* `splitter`:  An optional object implementing a `TextSplitter`, responsible for dividing the extracted text into chunks.\n* `splitter_config`: An object containing configuration parameters for the text splitter, such as `chunk_size` and `chunk_overlap`.\n* `timeout`: A time limit for the HTTP requests to the Tika server. \n* `max_retries`:   The maximum number of retries if the request to the Tika server fails.\n\n\n## [Output]\n\n* A list of `Document` objects, each containing a split portion of the extracted text. \n\n\n"
    },
    "quivr_core__quivr_rag__QuivrQARAG__build_chain": {
        "label": "build_chain",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 94,
        "endLineNo": 144,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L94-L144&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis function integrates a retrieval Augmented Generation (RAG) pipeline for question answering. It combines document retrieval, question reformulation, and LLM inference using a specified language model and chatbot history filtering. The purpose is to provide concise and relevant answers to questions by leveraging both pre-existing knowledge and a powerful language model.\n\n## Inputs\n\n* `self.reranker`: A document re-ranking model.\n* `self.retriever`: A document retrieval model.\n* `self.llm_endpoint`: An endpoint for interacting with a language model.\n* `self.rag_config`: A configuration object containing prompt details.\n* `files`: A collection of files for potential context.\n* `chat_history`: A history of previous conversations.\n* `question`: The user's question to be answered.\n\n## Output\n\n* `\"answer\"`: A string containing the generated answer from the language model.\n* `\"docs\"`: A list of retrieved documents relevant to the question. \n\n\n"
    },
    "quivr_core__brain__brain__Brain__afrom_files": {
        "label": "afrom_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 119,
        "endLineNo": 168,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L119-L168&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "* **Quick Summary:** This function creates a new knowledge base (brain) from a list of file paths. It uploads the files, processes their content, builds a vector database of the extracted information, and returns a Brain object representing the newly created knowledge base. \n\n* **Inputs:** \n    * `cls`: The class of the Brain object being created.\n    * `name`: The name of the new brain.\n    * `file_paths`: A list of file paths to be included in the brain.\n    * `vector_db`: (Optional) An existing vector database to use, otherwise a default one will be created.\n    * `storage`: (Optional) The storage backend to use for the brain's files.\n    * `llm`: (Optional) The language model to use for processing the files.\n    * `embedder`: (Optional) The embedding model to use for representing the file content as vectors.\n    * `skip_file_error`: Whether to skip files that can't be loaded.\n\n* **Output:** \n    *  A Brain object representing the newly created knowledge base. \n \n\n\n\n \n"
    },
    "quivr_core__files__file__QuivrFile": {
        "label": "QuivrFile",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 79,
        "endLineNo": 128,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L79-L128&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis code defines a `QuivrFile` class that represents a file within a system, likely a file storage or management system.  It stores file metadata like ID, path, filename, size, and hash, and provides methods to access and manage the file.  The code focuses on asynchronous file operations for efficiency.\n\n## Inputs\n\n* `id`:  Unique identifier for the file (UUID).\n* `original_filename`:  The original name of the file before possibly being renamed or stored.\n* `path`: The file's location on the file system (Path object).\n* `brain_id`:  Possibly an ID for the part of the system that owns or uses this file.\n* `file_md5`: A unique hash of the file content.\n* `file_extension`:  The file's extension (e.g., \".txt\", \".pdf\").\n* `file_size`:  Optional size of the file in bytes.\n\n## Output \n\n*  Instance of `QuivrFile` object containing the provided metadata.\n* `open(self)` method: An async generator yielding chunks of bytes from the file.\n* `metadata(self)` method:  A dictionary containing  key-value pairs representing file metadata.  \n\n\n"
    },
    "quivr_core__storage__local_storage__LocalStorage": {
        "label": "LocalStorage",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 11,
        "endLineNo": 60,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L11-L60&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Summary\n\nThis code defines a class `LocalStorage` that manages files stored locally on a computer, mimicking a simpler version of a distributed file storage system.  It handles file storage, retrieval, and management while considering potential file conflicts. \n\n[Inputs]\n\n* `file`: \n* `exists_ok`:  \n\n[Output]\n\n\n*  \n"
    },
    "quivr_core__storage__file__QuivrFile": {
        "label": "QuivrFile",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 65,
        "endLineNo": 111,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L65-L111&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis Python code defines a class to represent a file object with associated metadata. It provides methods for opening the file asynchronously and retrieving its metadata as a dictionary. The purpose is likely to manage and interact with files efficiently within a larger application, especially one involving asynchronous operations.\n\n## Inputs\n\n* `id`: Unique identifier (likely a UUID) for the file.\n* `original_filename`: The original name of the file before any potential renaming or modification.\n* `path`: The file's location on the system, likely represented as a `Path` object for easier path manipulation.\n* `brain_id`: Possibly an identifier for a model or system component that \"owns\" or is associated with the file.\n* `file_md5`: A cryptographic hash of the file content, used for integrity checking.\n* `file_extension`: The file's extension (e.g., \".txt\", \".jpg\").\n* `file_size`:  The file's size in bytes (optional).\n\n## Output\n\n* `metadata`: A dictionary containing information about the file: its ID, path, original name, MD5 hash, and size.  \n* `AsyncIterable[bytes]`: An asynchronous iterable object yielding bytes read from the file when `open()` is called.  \n\n\n"
    },
    "quivr_core__processor__implementations__default___build_processor___Processor": {
        "label": "_Processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 46,
        "endLineNo": 91,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L46-L91&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis: \n\n**Quick Summary:** This code defines a processor class that loads documents from a given file path, splits them into chunks using a specified text splitter, and returns the documents with their metadata. The overall purpose is to prepare documents for further processing, like summarization or question answering.\n\n**Inputs:**\n\n*   `file: QuivrFile`: A file object representing a document to be processed.\n*   `loader_cls`: A class that handles loading documents from the specified file.\n*   `loader_kwargs`: Additional keyword arguments passed to the document loader.\n*   `splitter: TextSplitter | None`: An optional text splitter object for splitting documents into chunks.\n*   `splitter_config: SplitterConfig`: Configuration for text splitting, including chunk size and overlap.\n\n**Output:**\n\n*   `list[Document]`: A list of `Document` objects, each containing the split chunks of text and metadata.\n"
    },
    "quivr_core__chat__ChatHistory": {
        "label": "ChatHistory",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 9,
        "endLineNo": 53,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L9-L53&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code defines a `Chat` class designed to store and manage the history of a conversation. It provides methods to access the chat history, add new messages, and iterate over pairs of human and AI messages. The purpose of this code is likely to facilitate the development of a chatbot or conversational AI system.\n\n## Inputs\n\n* `langchain_msg`: Represents either a human (`AIMessage`) or AI generated (`HumanMessage`) message.\n* `metadata`: A dictionary containing additional information about the message.\n\n## Output\n\n* `Generator[Tuple[HumanMessage, AIMessage], None, None]`: Yields pairs of `HumanMessage` and `AIMessage` objects, allowing iteration over the chat history in a human-AI message alternating format.\n"
    },
    "quivr_core__processor__registr__defaults_to_proc_entries": {
        "label": "defaults_to_proc_entries",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 85,
        "endLineNo": 129,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L85-L129&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick summary]\nThis function dynamically populates a `ProcMapping` object by importing and registering processors for different file extensions.  It aims to provide a flexible and extensible way to handle various file types.  \n\n[Inputs]\n* `base_processors`: An existing `ProcMapping` object likely containing default or base processors.\n\n[Output]\n* A modified `ProcMapping` object with additional processors registered based on the file extensions found in the code. \n\n\n"
    },
    "tests__test_quivr_rag__test_quivrqarag": {
        "label": "test_quivrqarag",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_quivr_rag.py",
        "relativePath": "backend/core/tests/test_quivr_rag.py",
        "lineNo": 26,
        "endLineNo": 68,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_quivr_rag.py%23L26-L68&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis of the Code Snippet\n\n**Quick Summary:** The code snippet is a test for a function (likely within a library) that interacts with an OpenAI model through a RAG (Retrieval Augmented Generation) pipeline. This test simulates a conversation and verifies the function's response format, content, and metadata.\n\n**Inputs:**\n\n* `mem_vector_store`:  In-memory vector store likely used for storing and retrieving context.\n* `full_response`: The expected complete answer from the RAG pipeline.\n* `mock_chain_qa_stream`: Likely a mocked stream object  to simulate the OpenAI API's response format.\n* `openai_api_key`: The API key needed to authenticate with the OpenAI API.\n\n**Output:**\n*  Success or failure based on the comparison of the generated responses with the expected `full_response` and metadata checks. \n\n\n\n"
    },
    "tests__test_utils__test_parse_chunk_response_func_calling": {
        "label": "test_parse_chunk_response_func_calling",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 67,
        "endLineNo": 108,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L67-L108&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]** \n\nThis code snippet processes a stream of chunks representing a response from an AI model. It aggregates these chunks into a coherent message,  stores the accumulated message history, and asserts the correctness of the aggregation process. \n\n**[Inputs]**\n\n* `chunks_stream_answer`: A stream or iterable of `AIMessageChunk` objects, representing the individual parts of the AI's response.\n\n**[Output]**\n\n* `rolling_msgs_history`: A list of  `AIMessageChunk` objects, containing the accumulated AI response chunks.\n* `answer_str_history`: A list of strings, containing the accumulated textual answer strings from each chunk. \n\n\n"
    },
    "quivr_core__processor__implementations__megaparse_processor__MegaparseProcessor": {
        "label": "MegaparseProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "lineNo": 16,
        "endLineNo": 56,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fmegaparse_processor.py%23L16-L56&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary \n\nThis function processes a QuivrFile, extracts text using `MegaParse`, optionally splits the text into chunks based on a specified chunk size, and returns a list of processed documents.  The purpose is to prepare textual data from a file for further processing (e.g., analysis, summarization) by breaking it down into manageable chunks.\n\n## Inputs\n\n*  `file`: A QuivrFile object containing the file path and potentially other metadata.\n*  `splitter`: An optional TextSplitter object used to split the extracted text into chunks.\n*  `splitter_config`: A SplitterConfig object defining parameters for text splitting, such as chunk size and overlap.\n*  `llama_parse_api_key`: An API key potentially required for using the `MegaParse` library.\n\n## Output\n\n*  A list of Document objects, each containing the extracted text and potentially other metadata (like chunk size).  \n\n\n"
    },
    "quivr_core__chat_llm__ChatLLM__answer_astream": {
        "label": "answer_astream",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 99,
        "endLineNo": 138,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L99-L138&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**Quick Summary:** This function, likely part of a chatbot system,  interacts with a RAG (Retrieval-Augmented Generation) model to provide segmented answers to a given question based on its history. It efficiently handles responses as chunks and aggregates them into a final, complete answer.\n\n**Inputs:**\n\n*  **`question`**: The user's query or question.\n*  **`history`**: A history of past interactions (past questions and answers) in a format like `ChatHistory`. This helps the RAG model provide contextually relevant answers.\n\n**Output:**\n\n*  **`AsyncGenerator[ParsedRAGChunkResponse, ParsedRAGChunkResponse]`**:  An asynchronous generator yielding `ParsedRAGChunkResponse` objects. Each response object contains:\n    *  **`answer`**:  A segment of the RAG model's response.\n    *  **`metadata`**:  Additional information about the chunk, such as source documents used.\n*  The generator also yields a final `ParsedRAGChunkResponse` object (`last_chunk`) containing the complete, assembled answer and comprehensive metadata.\n\n\n"
    },
    "quivr_core__processor__registr__register_processor": {
        "label": "register_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 166,
        "endLineNo": 205,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L166-L205&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**[Quick Summary]**\n\nThis function registers a processor for a specific file extension.  It checks if a processor for the given extension already exists and handles cases where an existing processor should be overridden or appended to. \n\n**[Inputs]**\n\n* `file_ext`: The file extension for which the processor is registered. (e.g., \".txt\", \".csv\")\n* `proc_cls`: The class of the processor to register. This can be either a string representing the module name or the actual class object.\n* `append`: A boolean indicating whether to append the new processor to existing ones for the given extension, or override existing mapping (default: True).\n* `override`: A boolean indicating whether to override an existing processor for the given extension (default: False).\n* `errtxt`:  Optional error text to use if the processor import fails (default: None).\n* `priority`: Optional integer priority for the processor (default: None).\n\n**[Output]**\n\n\n*  Successfully registers the processor for the specified file extension within a global registry.\n*  Raises a ValueError if appending is `False` and a processor with the same class is already registered.\n\n\n\n\n\n\n"
    },
    "main__on_chat_start": {
        "label": "on_chat_start",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/examples/chatbot/main.py",
        "relativePath": "backend/core/examples/chatbot/main.py",
        "lineNo": 8,
        "endLineNo": 46,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fexamples%2Fchatbot%2Fmain.py%23L8-L46&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**Quick Summary:** This function  receives a text file from the user, processes it to create a knowledge base (brain), stores relevant information in a session, and notifies the user that the system is ready for interaction.  The purpose appears to be setting up a conversational AI system where the user's input file forms the basis of the system's knowledge.\n\n**Inputs:**\n\n*  `cl`: Likely a client object for interacting with a chat platform or framework.\n* `Brain`: A class presumably used to represent and manage the knowledge base. \n* `tempfile`:  A module for generating temporary files. \n\n**Output:**\n\n* Updates the chat with a message indicating the file processing is complete and the AI is ready.\n* Stores the processed file path and the created knowledge base (`brain`) within the chat session.  \n\n\n\n"
    },
    "quivr_core__processor__registr___append_proc_mapping": {
        "label": "_append_proc_mapping",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 50,
        "endLineNo": 84,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L50-L84&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary**\n\nThis function manages a priority-based queue of processors that handle files based on their extension. It adds new processors to the queue, maintaining priority order, and ensures that each file extension has at least one associated processor.\n\n**Inputs**\n\n* `mapping`: A dictionary-like structure that maps file extensions to priority queues of processors.\n* `file_ext`: The file extension to associate a processor with.\n* `cls_mod`: A string representing the class module for the new processor.\n* `errtxt`: An error message to display if the processing fails.\n* `priority`: An optional integer representing the priority of the new processor.\n\n**Output**\n\n* Updates the `mapping` by adding the new processor to the appropriate file extension's queue, considering its priority.\n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase": {
        "label": "StorageBase",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 8,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L8-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Summary\n\nThis Python code defines an abstract base class `StorageType` for representing different types of storage systems. It enforces the definition of essential methods like `nb_files`, `get_files`, `upload_file`, and `remove_file` that concrete storage implementations must provide. \n\n## Inputs\n\n*  `file`:  A `QuivrFile` object representing the file to be uploaded.\n*  `exists_ok`:  A boolean flag indicating whether the file should be allowed to exist if it already exists.\n\n## Output\n\n\n*  `None`: The `upload_file` method doesn't explicitly return a value, indicating it performs the upload operation and doesn't return any data.   \n"
    },
    "quivr_core__chat_llm__ChatLLM__filter_history": {
        "label": "filter_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 27,
        "endLineNo": 60,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L27-L60&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis function filters a chat history to maintain a relevant context for a current question. It prioritizes recent messages and limits the total token count based on the LLM's input capacity and a maximum history length.\n\n[Inputs]\n* `self`: An instance of a class containing the  `llm_endpoint` attribute, used for accessing configuration parameters (like `max_input`). \n* `chat_history`:  An object representing the chat history, likely with a method `iter_pairs()` that yields pairs of human and AI messages. \n\n[Output]\n* `filtered_chat_history`: A list of AI and human messages, selected to be relevant to the current question based on the filtering rules.  \n\n\n\n"
    },
    "quivr_core__processor__processor_base__ProcessorBase": {
        "label": "ProcessorBase",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/processor_base.py",
        "relativePath": "backend/core/quivr_core/processor/processor_base.py",
        "lineNo": 14,
        "endLineNo": 47,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fprocessor_base.py%23L14-L47&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Summary: \n\nThis code defines a base class for processors that handle Quivr files.  Processors extend this class and implement specific logic for handling different file types. The core purpose is to standardize the processing of files within the Quivr system, ensuring consistent metadata and output generation.\n\n## Inputs:\n\n* `file`: A QuivrFile object representing the file to be processed. \n* **Attributes of `QuivrFile`** :  Likely includes information about the file's path, name, extension, and potentially metadata associated with the file itself.\n\n## Output:\n\n* A list of `Document` objects.\n* Each `Document` likely represents a parsed or processed unit of information extracted from the input `QuivrFile`. \n\n\n"
    },
    "quivr_core__brain__brain__Brain__afrom_langchain_documents": {
        "label": "afrom_langchain_documents",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 195,
        "endLineNo": 227,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L195-L227&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**[Quick summary] **\nThis function creates a new Brain object. It utilizes default LLMs and Embeddings if not provided, constructs a Vector Database from the input documents, and stores this information within the Brain object. The purpose is to  initialize a Brain for interacting with and processing text data.  \n\n**[Inputs]**\n* `cls`: The class of Brain object being created.\n* `name`:  A string representing the name of the new Brain.\n* `langchain_documents`: A list of Document objects representing the text data to be indexed.\n* `vector_db`: An optional VectorStore to be used for indexing. \n* `storage`: An optional storage mechanism (Defaults to TransparentStorage).\n* `llm`: An optional LLMEndpoint for text generation and understanding.\n* `embedder`: An optional Embeddings model for converting text into vectors. \n\n**[Output]**\n* A new Brain object with the following attributes:\n    * `id`: A unique identifier for the brain (UUID).\n    * `name`: The name of the brain.\n    * `storage`: The storage mechanism.\n    * `llm`: The LLmEndpoint.\n    * `embedder`: The Embeddings model. \n    * `vector_db`: The built VectorStore containing the indexed documents.  \n\n\n\n\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint__from_config": {
        "label": "from_config",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 26,
        "endLineNo": 58,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L26-L58&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:** This function initializes and returns a BaseLLM instance. It dynamically chooses between AzureChatOpenAI or ChatOpenAI based on the provided configuration (`config`) and initializes the selected model with the appropriate API key and base URL.\n\n**Inputs:**\n\n* `config`: A configuration object containing details like the model name (`model`), base URL (`llm_base_url`), and API key (`llm_api_key`).  \n\n**Output:**\n\n* An instance of a BaseLLM class (`cls`) initialized with the selected OpenAI model and the configuration details. \n\n\n\n"
    },
    "quivr_core__processor__registr__get_processor_class": {
        "label": "get_processor_class",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 133,
        "endLineNo": 165,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L133-L165&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary \n\nThis function fetches a processor class from a registry based on a given file extension. It prioritizes a known registry and falls back to a \"known_processors\" dictionary, attempting to load classes lazily and handling potential import errors.\n\n## Inputs\n\n* **file_extension**: A string representing the file extension (e.g., \".txt\", \".pdf\"). \n\n## Output\n\n* **cls**: A processor class instance.  \n"
    },
    "quivr_core__brain__brain__Brain__ask_streaming": {
        "label": "ask_streaming",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 278,
        "endLineNo": 309,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L278-L309&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis asynchronous function fetches answers to a given question using a RAG (Retrieval-Augmented Generation) model. It leverages a pre-trained language model (LLM), a vector database for storing knowledge, and a RAG pipeline to construct a comprehensive response based on the question and existing chat history.\n\n## Inputs\n\n*  `question`: The user's query or question.\n* `rag_config`: An optional configuration object specifying parameters for the RAG model, including the LLM to use.\n\n## Output\n\n* An `AsyncGenerator` yielding `ParsedRAGChunkResponse` objects, each containing a part of the generated answer. \n* The generator also updates the `chat_history` with the question and the final, concatenated answer."
    },
    "tests__processor__test_registr__test_append_proc_mapping": {
        "label": "test_append_proc_mapping",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 88,
        "endLineNo": 117,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L88-L117&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "This code defines a dictionary-like structure to manage file processing procedures (`ProcMapping`) associated with different file extensions.\n\n**Inputs:**\n\n* `proc_mapping`: A dictionary-like object that maps file extensions to lists of `ProcEntry` objects.\n* `file_ext`: A file extension (e.g., FileExtension.txt).\n* `cls_mod`: The class module string for the processor.\n* `errtxt`: An error message string.\n* `priority`: Optional, the priority of the processor.\n\n**Outputs:**\n\n* `proc_mapping` is modified with an additional `ProcEntry` object for the specified `file_ext`.\n\n\n\n"
    },
    "quivr_core__chat_llm__ChatLLM__build_chain": {
        "label": "build_chain",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 61,
        "endLineNo": 89,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L61-L89&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown\n\n**Quick Summary:** \nThis function prepares and processes user inputs to interact with a language model (likely for a conversational AI). It filters and formats the chat history, constructs a prompt for the language model, and combines inputs with the prompt to generate a response. The code aims to provide a structured and efficient framework for chatbot interactions.\n\n**Inputs:**\n\n* `self.filter_history(x[\"chat_history\"])`: Likely a function call to filter and modify the conversation history.  \n* `itemgetter(\"question\")`: A function to extract the \"question\" item from an input dictionary.\n* `itemgetter(\"chat_history\")`: A function to extract the \"chat_history\" item from an input dictionary.\n\n**Output:**\n\n* A dictionary containing \"answer\":\n    *  Value is a result from the combined language model (`llm`) with the formatted prompt and inputs.\n    \n* A lambda function returning an empty list, labeled \"docs\":\n\n\n"
    },
    "quivr_core__files__file__load_qfile": {
        "label": "load_qfile",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 50,
        "endLineNo": 78,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L50-L78&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:**\n\nThis function takes a file path as input, verifies the file exists, reads its contents to generate an MD5 hash, and then constructs a `QuivrFile` object containing information about the file like its ID, size, extension, and hash.  It likely forms part of a system for managing and tracking files. \n\n**Inputs:**\n\n* **path:** This is the path to a file.\n\n* **brain_id:** This is likely an ID associated with the system or service managing these files.\n\n**Output:**\n\n* A `QuivrFile` object, which likely contains the following attributes:\n    * `id`: A unique identifier for the file.\n    * `brain_id`: The ID associated with the managing system.\n    * `path`: The path to the file.\n    * `original_filename`: The original name of the file.\n    * `file_extension`: The extension of the file.\n    * `file_size`: The size of the file in bytes.\n    * `file_md5`: The MD5 hash of the file contents. \n\n\n\n"
    },
    "quivr_core__quivr_rag__QuivrQARAG__filter_history": {
        "label": "filter_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 65,
        "endLineNo": 93,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L65-L93&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function filters a chat history, keeping only the most relevant messages for a given question. It prioritizes recent conversations (up to `max_tokens` and `max_history`) and presents them in reverse chronological order.\n\n## Inputs\n\n*  `self`: This likely refers to an instance of a class containing the function.\n* `chat_history`:  A list of `HumanMessage` and `AIMessage` objects representing the conversation history. \n\n## Output\n\n* `filtered_chat_history`: A list of `AIMessage` and `HumanMessage` objects, containing only the most relevant messages from the input `chat_history`. \n\n\n"
    },
    "quivr_core__storage__file__load_qfile": {
        "label": "load_qfile",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 36,
        "endLineNo": 64,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L36-L64&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function processes a given file path, ensuring it's a valid file, reads the file's contents to calculate its MD5 hash, and generates a QuivrFile object representing the file. The purpose is to encapsulate file information and metadata for storage and retrieval within a system.\n\n**Inputs:**\n* **path:** The path to the file.\n* **brain_id:** Likely an identifier for the system or location where the file is stored.\n\n**Output:**\n* **QuivrFile object:** \n    * Contains file metadata: ID, brain ID, path, original filename, extension, file size, and MD5 hash. \n"
    },
    "quivr_core__brain__brain__Brain__ask": {
        "label": "ask",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 250,
        "endLineNo": 277,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L250-L277&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**Quick Summary:** \n\nThis function utilizes a RAG (Retrieval Augmented Generation) pipeline to answer a given question using a pre-existing knowledge base (vector_db) and a language model (LLM).  It incorporates the provided question into the chat history and returns the generated answer as a ParsedRAGResponse object. \n\n**Inputs:**\n\n* `question`: The user's query or question\n* `rag_config`:  (Optional)  Configuration for the RAG pipeline, potentially overriding the default LLM.\n\n**Output:**\n\n* `parsed_response`:  A `ParsedRAGResponse` object containing the generated answer (`answer` attribute) and potentially other relevant information. \n\n\n"
    },
    "quivr_core__brain__brain__process_files": {
        "label": "process_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 31,
        "endLineNo": 57,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L31-L57&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\nThis function processes documents stored in a given `storage` object. It iterates through files, identifies their type using file extension,  and uses the corresponding processor to extract knowledge from each file. \n\n\n## Inputs\n* `storage`: An object responsible for managing and accessing documents.\n* `skip_file_error`: A boolean flag indicating whether to skip files that cannot be processed.\n* `processor_kwargs`: Keyword arguments passed to the selected document processor.\n\n## Output\n* A list of processed documents (likely instances of a \"Document\" class). \n"
    },
    "quivr_core__processor__implementations__simple_txt_processor__SimpleTxtProcessor": {
        "label": "SimpleTxtProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "lineNo": 29,
        "endLineNo": 55,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fsimple_txt_processor.py%23L29-L55&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary**\n\nThis Python function processes a text file (.txt) asynchronously. It reads the file content, creates a `Document` object, splits it into smaller chunks based on the provided `splitter_config`, and returns a list of these processed document chunks. The purpose is likely to prepare text files for further processing or analysis by breaking them into manageable segments.\n\n**Inputs**\n\n*  `file`: A `QuivrFile` object representing the input text file.\n*  `splitter_config`: A `SplitterConfig` object containing parameters for splitting the text, such as `chunk_size` and `chunk_overlap`.\n\n**Output**\n\n* A list of `Document` objects, each representing a processed chunk of the original text file. \n\n\n\n\n"
    },
    "tests__fixture_chunks__main": {
        "label": "main",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/fixture_chunks.py",
        "relativePath": "backend/core/tests/fixture_chunks.py",
        "lineNo": 15,
        "endLineNo": 41,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ffixture_chunks.py%23L15-L41&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown \n\n**Quick Summary:**  This Python code sets up a question answering system using the Quivr library. It defines a pipeline that takes a question and a chat history as input, generates an answer using a GPT-4-powered language model, and saves the interaction as JSON data in a file. The purpose is to demonstrate a basic conversational question answering system. \n\n**Inputs:**\n\n* **\"What is NLP, give a very long detailed answer\"**: The user's question.\n* **chat_history**:  A ChatHistory object containing previous interactions in the conversation.\n\n**Output:**\n\n*  A JSONL file (\"response.jsonl\") containing a structured representation of the system's response to the question, including the question, answer, and other relevant metadata.\n\n\n\nLet me know if you'd like a more detailed explanation of any specific part of the code!"
    },
    "quivr_core__register_entries": {
        "label": "register_entries",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/__init__.py",
        "relativePath": "backend/core/quivr_core/__init__.py",
        "lineNo": 10,
        "endLineNo": 35,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2F__init__.py%23L10-L35&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**\n\nThis function attempts to load processor modules from an entry points file.  It determines the processor names and dynamically imports them, registering each processor with a specific name. It handles different entry points formats depending on the Python version and importlib-metadata library version. \n\n**[Inputs]**\n\n* **entry_points:** An object representing the entry points defined in the `setup.py` file, likely parsed by `importlib-metadata`.\n\n\n**[Output]**\n\n*  Registered processors: The function registers each processor module with a unique name, allowing for later invocation based on this name. \n"
    },
    "tests__processor__test_registr__test_append_proc_mapping_priority": {
        "label": "test_append_proc_mapping_priority",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 63,
        "endLineNo": 87,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L63-L87&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**Quick Summary**\n\nThis function (`_append_proc_mapping`) appends a new processor entry to an existing mapping of file extensions to processors. It prioritizes processors based on the specified `priority` value, with lower values having higher priority. \n\n**Inputs**\n\n* `proc_mapping`: A dictionary-like object (`ProcMapping`) that maps file extensions to a list of processors.\n* `file_ext`: The target file extension (likely an enumerated type like `FileExtension.txt`).\n* `cls_mod`: The Python module and class name of the processor to be added.\n* `errtxt`:  An optional error message to associate with this processor.\n* `priority`: An integer that determines the order in which processors are attempted.\n\n\n**Output**\n\n* The `proc_mapping` dictionary is modified.\n* The appended processor is placed in the list based on its `priority`. \n"
    },
    "quivr_core__brain__brain__Brain__from_files": {
        "label": "from_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 170,
        "endLineNo": 193,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L170-L193&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:** This Python function asynchronously processes files to build and store a data index, potentially using a vector database for efficient retrieval. It leverages asynchronous programming (asyncio) for efficiency and accepts various parameters to customize its operation. \n\n**Inputs:**\n\n- `cls`: Refers to the class this function belongs to, likely a specialized indexing class. \n- `*`:  Placeholder for any additional positional arguments.\n- `name`: String representing the name of the index being created.\n- `file_paths`: List of file paths (strings or Path objects) to be indexed.\n- `vector_db`: An optional `VectorStore` object for storing and querying embeddings.\n- `storage`:  A `StorageBase` object responsible for managing the index data.\n- `llm`: An optional `LLMEndpoint` object for generating embeddings.\n- `embedder`: An optional `Embeddings` object for generating embeddings.\n- `skip_file_error`: Boolean flag to control error handling when encountering file errors.\n\n**Output:**\n\n- An instance of the `cls` class, representing the created index. \n\n\n"
    },
    "quivr_core__utils__parse_chunk_response": {
        "label": "parse_chunk_response",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 90,
        "endLineNo": 113,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L90-L113&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown\n\n**Quick Summary:** This function processes an incoming message chunk and extracts any relevant tool function calls. If function calls are supported, it attempts to identify the tool call that generates the answer and returns both the updated message chunk and the extracted answer. Otherwise, it simply returns the original message chunk and the answer from the raw chunk. This likely occurs within a conversational AI system to manage and process user interactions. \n\n**Inputs:**\n* `rolling_msg`: An object representing a growing message conversation. Likely an AI message structure.\n* `raw_chunk`: A dictionary containing raw data from an incoming message, potentially including the answer.\n* `supports_func_calling`: A boolean flag indicating if the system supports calling external tools.\n\n**Output:**\n* `rolling_msg`: The updated message chunk.\n* `answer_str`: The extracted answer string. \n\n\n\n\n\n"
    },
    "quivr_core__brain__brain__Brain____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 59,
        "endLineNo": 81,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L59-L81&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function initializes an object that likely represents a chatbot or conversational AI agent. It sets up various components like chat storage, a language model, a vector database, and an embedding model.  The purpose is to create a ready-to-use framework for building a question-answering or conversational AI application.\n\n## Inputs\n\n* `name: str`: The name of the chatbot instance.\n* `id: UUID`: A unique identifier for the chatbot instance.\n* `vector_db: VectorStore`: A database capable of storing and retrieving vector embeddings.\n* `llm: LLMEndpoint`: Likely a pre-trained language model accessible through an API endpoint. \n* `embedder: Embeddings`: A function or class responsible for generating vector embeddings from text.\n* `storage: StorageBase`: A storage mechanism for persisting chatbot data, like conversation history. \n\n## Output\n\n*  None. The function likely sets up internal attributes and initializes data structures,  without directly returning anything.  \n\n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "quivr_core__processor__implementations__megaparse_processor__MegaparseProcessor____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "lineNo": 19,
        "endLineNo": 41,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fmegaparse_processor.py%23L19-L41&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary \n\nThis function initializes an object designed to process and split text for a large language model (LLM). \nIt likely prepares text data for interaction with an LLM, particularly one integrated with the MegaParse API.\n\n## Inputs\n\n* `splitter`: Accepts a custom `TextSplitter` object or `None`. \n* `splitter_config`: Configures text splitting parameters (likely chunk size, overlap). \n* `llama_parse_api_key`:  Key for accessing the MegaParse API for LLM interaction. \n* `strategy`: Defines the parsing strategy for MegaParse (e.g., \"fast\").\n\n## Output\n\n* Initializes internal attributes of the object:\n    * `loader_cls`: Sets the class responsible for loading text data (in this case, `MegaParse`).\n    * `enc`:  Likely a tokenization encoder from the `tiktoken` library.\n    * `splitter_config`: Stores the configuration for text splitting.\n    * `megaparse_kwargs`: Holds parameters for MegaParse API interaction.\n\n\n\n"
    },
    "tests__processor__test_txt_processor__test_process_txt": {
        "label": "test_process_txt",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_txt_processor.py",
        "relativePath": "backend/core/tests/processor/test_txt_processor.py",
        "lineNo": 22,
        "endLineNo": 44,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_txt_processor.py%23L22-L44&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown\n\n**Quick Summary:** This code snippet processes a text file (`txt_qfile`) using a custom text processor (`TikTokenTxtProcessor`) that splits the file into chunks. It then asserts that the processing was successful and that the metadata associated with the first chunk is as expected. The purpose is likely to test the functionality of the `TikTokenTxtProcessor`.\n\n**Inputs:**\n\n* `txt_qfile`: A text file object presumably containing the data to be processed. \n* `SplitterConfig`: An object defining the chunk size and overlap for the text splitting process.\n\n**Output:**\n\n* `doc`: A list of processed documents, each containing page content and metadata.\n* `assert` statements: These verify the following:\n    * The `doc` list is not empty.\n    * The content of the first chunk (`doc[0].page_content`) is correctly extracted as \"This is some test data.\"\n    * The metadata of the first chunk contains the expected information, including chunk index, file name, chunk size, processor class, splitter configuration, and other metadata from the original `txt_qfile`.\n"
    },
    "tests__test_brain__test_brain_info_empty": {
        "label": "test_brain_info_empty",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 130,
        "endLineNo": 152,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L130-L152&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:** This code initializes a `Brain` object, which likely represents an AI agent with memory and conversation capabilities. It sets up the brain's name, ID, LLM (large language model), embedding system, storage, and default chat. The purpose is to create a structured representation of the brain and its initial state.\n\n**Inputs:**\n\n* `storage`: A `TransparentStorage` object, likely for storing files and other data related to the brain.\n* `id`: A unique ID generated using `uuid4()`, used to identify the brain instance.\n* `fake_llm`: A placeholder or mock LLM, representing the language processing engine of the brain.\n* `embedder`: An embedding system, possibly for representing text as vectors for storage and retrieval.\n* `mem_vector_store`: An in-memory vector store, used for efficient storage and searching of embeddings.\n\n**Output:**\n\n* An instance of the `Brain` class, with the specified configuration and initial state. \n* An assertion that checks if the output of `brain.info()` matches a predefined dictionary, ensuring the brain object is initialized correctly. \n"
    },
    "quivr_core__processor__implementations__tika_processor__TikaProcessor____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/tika_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/tika_processor.py",
        "lineNo": 19,
        "endLineNo": 40,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Ftika_processor.py%23L19-L40&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis Python function initializes a Tika library client for extracting text from various document types. It configures the client with a specified URL, timeout, maximum retries, and a text splitter to process the extracted text efficiently. The purpose is to streamline and optimize text extraction from diverse file formats.\n\n\n## Inputs\n\n* **tika_url:** URL of the Tika server.\n* **splitter:**  Optional TextSplitter object for splitting the extracted text.\n* **splitter_config:**  SplitterConfig object defining parameters for text splitting.\n* **timeout:** Maximum time allowed for Tika server response in seconds.\n* **max_retries:** Maximum number of times to retry a request in case of failure.\n\n## Output\n\n* Initializes an instance of the class with the provided configurations, ready to extract text from documents.\n"
    },
    "quivr_core__utils__parse_response": {
        "label": "parse_response",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 115,
        "endLineNo": 136,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L115-L136&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function processes the raw response from a RAG (Retrieval-Augmented Generation) system, extracts relevant information, and structures it into a more usable format.  The goal is to present the answer and its associated metadata in a standardized way for further processing or display.\n\n## Inputs\n\n* **raw_response**: This is assumed to be a dictionary-like structure containing the raw output from the RAG model. \n* **model_name**: A string representing the name of the underlying RAG model used to generate the response.\n\n## Output\n\n* **parsed_response**: An object presumably of type `ParsedRAGResponse` containing:\n    * `answer`: The actual textual answer generated by the RAG model.\n    * `metadata`: An object containing additional information about the response, including:\n        * `sources`: A list of sources used by the model to generate the answer.\n        * `citations`: A list of citations extracted from the tool calls.\n        * `followup_questions`: A list of suggested follow-up questions. \n\n\n\n\n"
    },
    "tests__test_brain__test_brain_from_files_success": {
        "label": "test_brain_from_files_success",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 38,
        "endLineNo": 59,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L38-L59&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]** \nThis function tests the initialization and basic functionality of a `Brain` object, verifying its attributes and storage setup. It aims to ensure the Brain object is created correctly and can store data.\n\n**[Inputs]**\n\n* `fake_llm`: A mock or placeholder object representing a Large Language Model (LLM).\n* `embedder`: An object responsible for generating vector embeddings from text.\n* `temp_data_file`: A local file path containing temporary data for the Brain.\n* `mem_vector_store`: An in-memory vector store used to manage embeddings.\n\n**[Output]**\n\n*  Assertions verifying the Brain object's attributes and functionalities.\n* Confirmation that the Brain object can store files.  \n\n\n\n"
    },
    "quivr_core__brain__info__BrainInfo": {
        "label": "BrainInfo",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 54,
        "endLineNo": 74,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L54-L74&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function `to_tree()` takes a Brain object and converts its information into a hierarchical tree structure suitable for display using a tool like  `rich`.  This likely aids in visualizing and presenting brain-related data in a user-friendly way. \n\n## Inputs\n\n* `self`:  A Brain object containing various attributes about the brain.\n* `Brain object`: An object likely holding information like a unique identifier (`brain_id`), a name (`brain_name`), file details (`files_info`), chat history (`chats_info`), and LLM specifications (`llm_info`).\n\n## Output\n\n* `tree`: A Tree object representing the hierarchical structure containing information about the Brain. The tree would have branches for \"ID\", \"Brain Name\", \"Files\", \"Chats\", and \"LLM\", each displaying relevant details. \n\n\n\nLet me know if you'd like me to elaborate on any specific aspect.\n"
    },
    "quivr_core__processor__implementations__default___build_processor___Processor____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 49,
        "endLineNo": 69,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L49-L69&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**Quick Summary:**\n\nThis function initializes a data loader, responsible for reading and processing text data. It takes a custom class (`load_cls`) and keyword arguments for loading the data, along with configuration for text splitting (`splitter_config`). It uses a `RecursiveCharacterTextSplitter` for splitting by default, unless a custom splitter is provided.\n\n**Inputs:**\n\n* `load_cls`: A class responsible for loading the text data.\n* `splitter`: An optional custom text splitter object.\n* `splitter_config`: A configuration object controlling the text splitting process (chunk size, chunk overlap). \n* `loader_kwargs`: Additional keyword arguments passed to the `load_cls` for data loading.\n\n**Output:**\n\n* Initializes the data loader object with the specified parameters and configurations. \n\n\nLet me know if you'd like me to elaborate on any specific aspect of the code!\n"
    },
    "quivr_core__utils__get_chunk_metadata": {
        "label": "get_chunk_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 58,
        "endLineNo": 78,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L58-L78&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis of Provided Code Snippet\n\n**Quick Summary:** This function processes an AIMessageChunk object (`msg`) and a list of sources to extract metadata related to tool calls used within the message. Specifically, it aims to identify citations and follow-up questions generated by invoked tools and embed them within the response metadata.\n\n**Inputs:**\n\n* `msg`: An AIMessageChunk object, likely representing a user message containing tool calls.\n* `sources`: A list of sources potentially related to the message context.\n\n**Output:**\n\n* `RAGResponseMetadata`: A dictionary-like object populated with metadata extracted from the message, including:\n    * `sources`: The initial list of sources passed to the function.\n    * `citations`: A list of citations extracted from tool call arguments if available.\n    * `followup_questions`: A list of follow-up questions extracted from tool call arguments if available. \n\n\n"
    },
    "quivr_core__brain__brain_defaults__build_default_vectordb": {
        "label": "build_default_vectordb",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain_defaults.py",
        "relativePath": "backend/core/quivr_core/brain/brain_defaults.py",
        "lineNo": 13,
        "endLineNo": 32,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain_defaults.py%23L13-L32&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**[Quick summary]** \n\nThis function attempts to initialize a FAISS vector store from a provided list of documents and an embedding function. Its purpose is to create an efficient in-memory database for storing and querying document embeddings, likely for semantic search applications.\n\n**[Inputs]**\n\n* `docs`:  A list of `Document` objects, representing the textual data to be indexed.\n* `embedder`: An instance of an `Embeddings` class, responsible for converting documents into numerical vector representations.\n \n**[Output]**\n* A `FAISS` object representing the initialized vector store, ready for storing and querying document embeddings. \n\n\n"
    },
    "quivr_core__files__file__FileExtension": {
        "label": "FileExtension",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 14,
        "endLineNo": 33,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L14-L33&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## File Type Variables\n\n[Quick Summary] \nThis code defines a set of variables, each representing a common file extension. The purpose is to  store and easily reference these file types within a program. \n\n[Inputs]\n* There are no explicit inputs to the code.\n\n[Output]\n*  A collection of variables holding file extensions:\n    * `.txt`\n    * `.pdf`\n    * `.csv`\n    * `.doc`\n    * `.docx`\n    * `.pptx`\n    * `.xls`\n    * `.xlsx`\n    * `.md`\n    * `.mdx`\n    * `.markdown`\n    * `.bib`\n    * `.epub`\n    * `.html`\n    * `.odt`\n    * `.py`\n    * `.ipynb` \n\n\n"
    },
    "quivr_core__processor__registr___import_class": {
        "label": "_import_class",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 206,
        "endLineNo": 225,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L206-L225&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown:\n\n**Quick Summary:** This function imports and validates a custom processor class. It takes a string specifying the full module path (e.g., \"my_module.MyProcessor\"), dynamically finds the class within the module, and ensures it's a subclass of a base processor class (`ProcessorBase`). \n\n**Inputs:**\n\n* `full_mod_path`: A string representing the fully qualified path to the processor class, following the format \"module.class\" or \"module:class\".\n\n**Output:**\n\n* The `mod` object, which is the imported and validated custom processor class instance. \n\n\n"
    },
    "quivr_core__quivr_rag__QuivrQARAG__answer": {
        "label": "answer",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 145,
        "endLineNo": 164,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L145-L164&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function orchestrates a Retrieval Augmented Generation (RAG) process. It takes a user question, conversation history, a list of relevant files, and other metadata, formats the files, constructs a question-answering chain, and utilizes a large language model (LLM) to generate a response.  \n\n## Inputs\n\n* **question**: The user's query.\n* **history**:  Previous interactions in the conversation.\n* **list_files**:  A collection of files potentially containing information to answer the question.\n* **metadata**: Additional context or instructions for the LLM.\n\n## Output\n\n* **ParsedRAGResponse**: A structured response generated by the LLM, incorporating information from the provided files.  \n"
    },
    "quivr_core__brain__info__LLMInfo": {
        "label": "LLMInfo",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 24,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L24-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis Python function `add_to_tree` takes an instance of a `Tree` object and adds information about a specific large language model (LLM) to its structure.  It's likely used to create a formatted, visual representation of LLM parameters for display or analysis.\n\n## Inputs\n\n*  `self`:  Refers to the current instance of a class (likely an LLM configuration class).\n*  `llm_tree`: An instance of a `Tree` object. This likely represents a hierarchical data structure used to organize and display information.\n\n## Output\n\n* Modifies the input `llm_tree` object by adding the following information as nodes:\n    *  Model name (in italics format)\n    *  LLM base URL (underlined format)\n    *  Temperature value (in bold format)\n    *  Maximum tokens value (in bold format)\n    *  Whether the LLM supports function calling (in bold with green for \"True\" and red for \"False\")\n"
    },
    "quivr_core__processor__processor_base__ProcessorBase__process_file": {
        "label": "process_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/processor_base.py",
        "relativePath": "backend/core/quivr_core/processor/processor_base.py",
        "lineNo": 26,
        "endLineNo": 44,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fprocessor_base.py%23L26-L44&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**Quick Summary:**\n\nThis function processes a file, likely a document, into a list of individual documents (chunks). It then adds metadata to each document, including a unique ID, chunk index, version of the Quivr core library, and other relevant information.\n\n**Inputs:**\n\n*  `file`: This likely represents a file object containing the document to be processed.\n*  `self`: This suggests the function is a method within a class, and `self` refers to the instance of that class.\n\n**Output:** \n\n*  `docs`: A list of processed document objects, each containing metadata about its origin and structure. \n\n\n\n"
    },
    "quivr_core__storage__local_storage__TransparentStorage": {
        "label": "TransparentStorage",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 61,
        "endLineNo": 79,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L61-L79&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis of Transparent Storage Code\n\n**Quick Summary:** This code defines a basic \"transparent storage\" system, likely mimicking a simplified file storage backend. It tracks files by ID and allows uploading new files while providing methods to retrieve the total number of stored files.\n\n**Inputs:**\n* `file`: An object representing a file with an `id` attribute.\n* `exists_ok`: A boolean flag indicating whether to overwrite existing files (default: False).\n* `file_id`: A unique identifier (UUID) representing a file to be removed.\n\n**Output:**\n* List of `QuivrFile` objects, representing all stored files. \n* None (indicates successful file upload or removal). \n\n\n\n"
    },
    "tests__test_brain__test_brain_search": {
        "label": "test_brain_search",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 77,
        "endLineNo": 95,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L77-L95&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**Quick Summary:** This code tests the functionality of a `Brain` object from a LangChain-compatible framework. It creates a `Brain` by feeding two documents into it, then searches within that brain for one of the documents and verifies the search results match expectations.\n\n**Inputs:**\n\n* `embedder`: An embedding model used to represent the documents as vectors.\n* `content_1`: The text content of the first document.\n* `content_2`: The text content of the second document.\n* `k`: The number of search results to return (set to 2 in this case).\n\n**Output:**\n\n* A list of `Result` objects containing the matching documents, their distance scores to the query, and metadata. \n* The expected list has two elements, corresponding to the two input documents. \n* The distance score for the first result should be 0 (exact match) and the second result should have a higher distance. \n\n\n\n"
    },
    "tests__test_chat_histor__test_chat_history_get_history": {
        "label": "test_chat_history_get_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 38,
        "endLineNo": 56,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L38-L56&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Python Code Analysis\n\n**Quick Summary:** This code snippet simulates a simple chat history and asserts its functionality. It creates a `ChatHistory` object, appends messages to it, retrieves the history with different ordering options, and verifies that the retrieval and timestamps work correctly.\n\n**Inputs:**\n\n*  `ai_message`: An instance of an `AIMessage` class representing a message from an AI.\n*  `human_message`: An instance of a `HumanMessage` class representing a message from a human user.\n\n*  `newest_first`: A boolean parameter (defaulting to False) used for controlling the order of retrieved messages in `get_chat_history`.\n\n**Output:**\n\n* `msgs`: A list of `Message` objects representing the chat history.\n*  The code asserts that the retrieved messages are ordered correctly based on the `newest_first` parameter. \n\n\n"
    },
    "quivr_core__files__file__QuivrFile____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 90,
        "endLineNo": 107,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L90-L107&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**Summary:**\n\nThis Python function initializes an object, likely representing a file stored within a system.  It sets various attributes of the file, including its unique identifier, parent brain's ID, location, original name, size, extension, and MD5 hash. The purpose is likely to manage and track files within a data storage or processing application.\n\n**Inputs:**\n\n* `id`: A unique identifier for the file (UUID type).\n* `original_filename`: The filename as given by the user (string type).\n* `path`: The file's location on the system (Path type). \n* `brain_id`: A unique identifier for the parent \"brain\" or container (UUID type).\n* `file_md5`: A cryptographic hash of the file's content (string type).\n* `file_extension`: The file's extension (FileExtension enum or string type).\n* `file_size`: The file's size in bytes (integer or None type).\n\n**Output:**\n\n* None - This function likely modifies the object it's called on and doesn't directly return a value. \n\n\n\n"
    },
    "quivr_core__models__cited_answer": {
        "label": "cited_answer",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 13,
        "endLineNo": 30,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L13-L30&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown:\n\n**[Quick Summary]**  \n\nThis Python code defines a function that processes a user question and produces an answer, a list of source citations, and up to three follow-up questions. The purpose is to create a system capable of providing informative responses grounded in given sources while stimulating further inquiry. \n\n**[Inputs]**\n\n*  **user question:** The prompt or question posed by the user.\n*  **given sources:** A collection of information sources that the function will use to formulate its answer. \n\n**[Output]**\n\n*  **answer:** A textual response directly addressing the user's question, derived from the provided sources.\n*  **citations:**  Integer IDs uniquely identifying the specific sources used to support the answer.\n*  **followup_questions:** A list of up to three additional questions that build upon the provided answer or context. \n\n\n"
    },
    "quivr_core__storage__file__QuivrFile____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 76,
        "endLineNo": 93,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L76-L93&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:** This Python function initializes a `File` object, likely used to represent a file stored within a file system or data structure. It stores information about the file, including its identifier, original name, location on disk, and some security/integrity checks (brain_id, md5 hash).\n\n**Inputs:**\n\n* `id`: Unique identifier for the file (likely a UUID)\n* `original_filename`: The name of the file as it was originally uploaded.\n* `path`: The location of the file on disk.\n* `brain_id`: Possibly an identifier for the dataset or project the file belongs to.\n* `file_md5`: A cryptographic hash of the file content, used for integrity verification.\n* `file_extension`: Indicates the file type (e.g., .jpg, .txt). Can be a custom enum or a string.\n* `file_size`: Optional integer representing the file size in bytes.\n\n**Output:**\n\n*  None (This function appears to be an initializer, setting internal attributes of the `File` object)  \n\n\n"
    },
    "tests__processor__test_registr__test_register_override_error": {
        "label": "test_register_override_error",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 208,
        "endLineNo": 225,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L208-L225&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:** This code snippet aims to register a custom PDF processor with a framework. However, it's structured to fail due to a specific configuration. The purpose appears to be testing the error handling when attempting to register a processor for an already existing extension.\n\n**Inputs:**\n* `FileExtension.pdf`: Represents the PDF file extension. Likely a class or enum value.\n* `TestProcessor`: A custom processor class inheriting from `ProcessorBase`, indicating it handles PDF files.\n* `override=False`: A boolean flag potentially controlling whether to overwrite an existing processor for `.pdf`.\n\n**Output:**\n* `ValueError`: An error is raised, signifying a conflict in processor registration.  \n"
    },
    "quivr_core__brain__brain__Brain__info": {
        "label": "info",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 92,
        "endLineNo": 108,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L92-L108&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis Python function `info()` retrieves and structures information about a particular Brain instance. It gathers details about files, chats, the current active chat, and the underlying LLM. This information is likely intended for display or analysis purposes, providing a comprehensive overview of the Brain's state. \n\n## Inputs\n*  `self`:  A reference to the current `Brain` object. \n    \n*  `self._chats`: A collection of chat histories, potentially stored as a list or dictionary.\n*  `self.default_chat`:  Represents the currently active or selected chat history.\n*  `self.storage`: An object presumably managing the storage of files associated with the Brain.\n*  `self.llm`: An object representing the Large Language Model (LLM) used by the Brain.\n\n## Output\n*   `BrainInfo`: An object containing structured information about the Brain, likely with attributes like:\n    *  `brain_id`:  A unique identifier for the Brain.\n    *  `brain_name`: The name given to the Brain.\n    *  `files_info`: Information about the files stored by the Brain (format depends on `self.storage`).\n    *  `chats_info`:  Details about the Brain's chat history, including:\n        *  `nb_chats`: The total number of chat histories.\n        *  `current_default_chat`:  ID of the active chat.\n        *  `current_chat_history_length`:  The length (number of messages) in the active chat history. \n    *  `llm_info`:  Information about the underlying LLM, potentially including its type, version, etc."
    },
    "quivr_core__processor__implementations__simple_txt_processor__recursive_character_splitter": {
        "label": "recursive_character_splitter",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "lineNo": 12,
        "endLineNo": 28,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fsimple_txt_processor.py%23L12-L28&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis function recursively splits a `Document` object into smaller chunks of specified size (`chunk_size`) with a defined overlap (`chunk_overlap`). The purpose is to break down large documents into manageable pieces for processing.\n\n## Inputs\n- `doc`: A `Document` object containing text content (`page_content`) and metadata.\n- `chunk_size`: An integer representing the maximum size of each chunk.\n- `chunk_overlap`: An integer representing the number of characters that should overlap between consecutive chunks.\n\n## Output\n- A list of `Document` objects, each representing a chunk of the original document. \n\n\n"
    },
    "quivr_core__storage__local_storage__LocalStorage__upload_file": {
        "label": "upload_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 37,
        "endLineNo": 53,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L37-L53&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**Quick Summary**\n\nThis function uploads a file to a specified directory based on the file's metadata (brain_id, id, file_extension). It checks if a file with the same MD5 hash already exists and raises an error if so. The file is then copied or symlinked to the destination path and added to a list of files.\n\n**Inputs**\n\n* **file:** An object containing file metadata (brain_id, id, file_extension, path, original_filename, file_md5).\n* **dir_path:** The directory where the file will be uploaded.\n* **copy_flag:** A boolean indicating whether to copy or symlink the file.\n* **exists_ok:** A boolean indicating whether to allow files with the same MD5 hash to already exist.\n\n\n**Output**\n\n* Modified `file` object: The `file.path` attribute is updated to the destination path.\n* `self.files`: A list that now includes the uploaded file.\n* `self.hashes`: A set containing the file's MD5 hash.\n"
    },
    "quivr_core__utils__model_supports_function_calling": {
        "label": "model_supports_function_calling",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 24,
        "endLineNo": 40,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L24-L40&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**[Quick summary]**\n\nThis Python function checks if a given `model_name` supports function calls. It compares the input `model_name` against a list of OpenAI models known to support function calls, returning `True` if a match is found and `False` otherwise. This is likely used to determine which models can be used for advanced applications requiring function execution within the model.\n\n**[Inputs]**\n\n* `model_name`: A string representing the name of the OpenAI model being queried.\n\n**[Output]**\n\n* `True`: If the `model_name` is found in the list of models supporting function calls.\n* `False`: If the `model_name` is not found in the list.  \n\n\n\n"
    },
    "tests__processor__test_registr__test_append_proc_mapping_empty": {
        "label": "test_append_proc_mapping_empty",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 46,
        "endLineNo": 62,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L46-L62&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**\n\nThis function, `_append_proc_mapping`,  adds a mapping between a specific file extension (`txt`) and a `ProcEntry` object.  ProcEntry objects likely hold information about how to process files of that extension (e.g., using a specific module). The purpose of the code snippet is to demonstrate how to add these mappings.\n\n**[Inputs]**\n\n* `proc_mapping`:  A dictionary that seems to store file extension mappings to `ProcEntry` objects.\n* `file_ext`: Likely a `FileExtension` enum value representing the file type to map (e.g., `.txt`).\n* `cls_mod`: Likely a string representing the Python module or class responsible for processing files of the given extension.\n* `errtxt`: A string representing an error message to be used when processing files of this type.\n* `priority`: (Optional)  Could be an integer representing the priority of this processing rule.\n\n**[Output]**\n\n* An updated `proc_mapping` dictionary with a new entry for `.txt`.\n* This entry will contain a list containing a `ProcEntry` object with the provided attributes (`cls_mod`, `errtxt`, and a priority of `_LOWEST_PRIORITY`). \n\n\n\n\n"
    },
    "tests__test_brain__test_brain_get_history": {
        "label": "test_brain_get_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 97,
        "endLineNo": 113,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L97-L113&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick summary:** This code creates a temporary brain instance using provided files, an embedder, an LLM, and a memory vector store. It then interacts with the brain by asking two questions and asserts that the chat history has four entries. The purpose is likely to test the functionality of  brain object and its interaction with external components.\n\n**Inputs:**\n- `fake_llm`: A simulated Large Language Model.\n- `embedder`: A function or object used to generate embeddings for text.\n- `temp_data_file`: A file containing training or conversational data for the brain.\n- `mem_vector_store`: A memory storage system for vector embeddings. \n\n**Output:**\n-  The `brain.default_chat` attribute will contain a list of four entries, representing the two questions asked and the corresponding responses from the brain.\n\n\n"
    },
    "tests__test_config__test_default_llm_config": {
        "label": "test_default_llm_config",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_config.py",
        "relativePath": "backend/core/tests/test_config.py",
        "lineNo": 4,
        "endLineNo": 20,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_config.py%23L4-L20&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**\nThis Python code snippet appears to be asserting that the `model_dump()` method of the `LLMEndpointConfig` class returns a  correctly formatted string representation of the configuration object's attributes. \n\n**[Inputs]**\n* `config`: An instance of the `LLMEndpointConfig` class, which presumably holds settings for interacting with a language model.\n* `LLMEndpointConfig`: A custom class, likely defining attributes related to language model endpoints, such as model name, API key, and generation parameters.\n * `model_dump()`: A method within the `LLMEndpointConfig` class that serializes the configuration object into a string.\n\n**[Output]**\n* `True`: An assertion will pass if the string representation generated by `model_dump()` matches the expected format. \n* `False`: An assertion will fail if the generated string representation does not match the expected format, indicating a potential issue with the `model_dump()` method. \n\n\n\n"
    },
    "tests__test_llm_endpoint__test_llm_endpoint_from_config_default": {
        "label": "test_llm_endpoint_from_config_default",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_llm_endpoint.py",
        "relativePath": "backend/core/tests/test_llm_endpoint.py",
        "lineNo": 12,
        "endLineNo": 28,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_llm_endpoint.py%23L12-L28&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis \n\n\n**Quick Summary:**\n\nThis code tests the functionality of initializing and using an `LLMEndpoint` from the `langchain_openai` library. It checks for proper initialization with and without an `OPENAI_API_KEY` and verifies the type and configuration of the underlying `ChatOpenAI` instance.\n\n**Inputs:**\n\n*  `LLMEndpointConfig()`: An empty configuration object for `LLMEndpoint`.\n* `config`: An `LLMEndpointConfig` object with the `llm_api_key` set to \"test\".\n* `pytest.raises(ValidationError)`: A pytest fixture used to assert a specific exception.\n\n**Output:**\n\n*  `ValidationError`: Raised when `LLMEndpoint` is initialized without an API key.\n*  A correctly initialized `LLMEndpoint` instance with `supports_func_calling()`, `_llm` (an instance of `ChatOpenAI`), and `model_name`  as expected. \n\n\n\n"
    },
    "tests__test_utils__test_get_prev_message_str": {
        "label": "test_get_prev_message_str",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 28,
        "endLineNo": 44,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L28-L44&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown: \n\n**Quick Summary:** \nThe provided code snippet tests the `get_prev_message_str` function, which aims to extract the previous message content from an `AIMessageChunk` object. \n\n**Test Cases:**\n- It first tests an empty chunk and expects an empty string as output.\n- Then, it tests a chunk with a `cited_answer` tool call containing \"this is an answer\" and expects \"this is an answer\" as output. \n\n\n**Inputs**\n-  `chunk`: An object of type `AIMessageChunk`. \n\n**Output**\n\n- The function returns a string representing the previous message content. \n\n\n\n\nLet me know if you'd like me to elaborate on anything!\n"
    },
    "quivr_core__files__file__get_file_extension": {
        "label": "get_file_extension",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 34,
        "endLineNo": 49,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L34-L49&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function tries to determine the file extension of a given file path.  It prioritizes using the MIME type to infer the extension but falls back to the file's suffix if the MIME type is unknown or unparsable.  It also issues a warning if the file extension is not recognized. \n\n## Inputs\n\n* **file_path.name:** This likely refers to the name of the file without its full path.\n\n## Output\n\n* **FileExtension:**  An object presumably representing the determined file extension (as a string).\n\n\n\n"
    },
    "quivr_core__storage__file__get_file_extension": {
        "label": "get_file_extension",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 20,
        "endLineNo": 35,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L20-L35&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown\n\n**Quick Summary:**\n\nThis function attempts to determine the file extension of a given file path. It first tries to guess the MIME type of the file and then use that to infer the extension. If that fails, it uses the file's suffix as the extension. It also issues a warning if the file extension is not recognized.\n\n**Inputs:**\n* `file_path`: A file path representing the location of the file.\n\n**Output:**\n* `FileExtension`: An object representing the determined file extension. \n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "tests__processor__test_registr__test_register_new_proc": {
        "label": "test_register_new_proc",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 168,
        "endLineNo": 183,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L168-L183&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick summary:**\n\nThis code defines and registers a new processor type called `TestProcessor`, which processes files with the extension \".test\". It then verifies the registration by checking the size of the processor registry and retrieving the processor class associated with the \".test\" extension.\n\n**Inputs:**\n\n* `registry`: A list (or similar data structure) containing registered processor classes.\n* `QuivrFile`: A data structure representing a file within the system. \n* `ProcessorBase`: A base class for all processors.\n\n**Output:**\n\n*  No direct output, it modifies the `registry`. It asserts:\n    * The `registry` size increases by one after registering `TestProcessor`.\n    * The retrieved processor class for \".test\" is `TestProcessor`.\n\n\n"
    },
    "tests__processor__test_registr__test_register_override_proc": {
        "label": "test_register_override_proc",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 192,
        "endLineNo": 207,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L192-L207&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis code defines a mock processor called `TestProcessor` specifically for PDF files and registers it as the handler for the \".pdf\" extension. It then verifies that the registered processor for PDFs is indeed the `TestProcessor` class. The purpose is to test the processor registration mechanism.\n\n[Inputs]\n- `FileExtension.pdf`: Represents the file extension \".pdf\"  \n\n[Output]\n- `TestProcessor`: The class representing the registered processor for PDF files \n\n\n"
    },
    "quivr_core__brain__info__ChatHistoryInfo": {
        "label": "ChatHistoryInfo",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 8,
        "endLineNo": 22,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L8-L22&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the provided code snippet:\n\n**Quick Summary**\n\nThis function, `add_to_tree`, takes a `Tree` object and populates it with formatted text representing the current state of a chat application. It likely displays these attributes for monitoring or debugging purposes.\n\n**Inputs**\n\n* `chats_tree`:  A `Tree` object, presumably used for hierarchical data representation.\n* `self.nb_chats`: An integer representing the number of chat conversations.\n* `self.current_default_chat`: A Universally Unique Identifier (UUID) likely specifying the ID of the currently active default chat.\n* `self.current_chat_history_length`: An integer indicating the length of the history for the current chat.\n\n**Outputs**\n\n* The `chats_tree` object is modified to include these three key attributes of the chat application:\n    * Number of chats \n    * The ID of the default chat\n    * The length of the current chat history \n\n\n\n"
    },
    "quivr_core__processor__implementations__default___build_processor___Processor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 77,
        "endLineNo": 91,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L77-L91&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down the Python code snippet. \n\n**Quick Summary**\n\nThis function processes a collection of documents. It loads documents from a given file path, splits them into smaller chunks, and adds metadata about the chunk size to each document.\n\n**Inputs**\n\n*  `file_path`: The path to a file containing the documents to be processed.\n*  `self.loader_cls`:  A class responsible for loading documents from a specific source.\n*  `self.loader_kwargs`: Keyword arguments to be passed to the document loader class's constructor.\n \n*  `self.text_splitter`: An object capable of splitting documents into smaller units (likely sentences or paragraphs). \n* `enc`: An encoding object (probably, `.encode` is being used).\n\n**Output**\n\n\n* `docs`: A list of document objects, each containing:\n   * `page_content`: The original textual content.\n   * `metadata`: A dictionary containing information about the chunk size of the document. \n"
    },
    "tests__processor__docx__test_docx__test_docx_filedocx": {
        "label": "test_docx_filedocx",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/docx/test_docx.py",
        "relativePath": "backend/core/tests/processor/docx/test_docx.py",
        "lineNo": 12,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fdocx%2Ftest_docx.py%23L12-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**Quick Summary:** This Python code snippet tests a document processor named `DOCXProcessor`. It creates a `QuivrFile` object representing a DOCX file, processes it using the processor, and then asserts that the result is not empty.\n\nThis likely verifies that the `DOCXProcessor` can successfully extract data or perform some operation on a DOCX file.\n\n**Inputs:**\n\n* `p`: A `Path` object pointing to a DOCX file named \"demo.docx\".\n* `DOCXProcessor()`: An instance of a class responsible for processing DOCX files.\n\n**Output:**\n\n* `result`: A data structure (list, dictionary, etc.) containing the output of the document processing.\n   * The assertion ensures that `result` is not empty, indicating successful processing. \n\n\n\nLet me know if you need further details or have other code snippets to analyze!\n"
    },
    "tests__processor__epub__test_epub_processor__test_epub_page_blanche": {
        "label": "test_epub_page_blanche",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/epub/test_epub_processor.py",
        "relativePath": "backend/core/tests/processor/epub/test_epub_processor.py",
        "lineNo": 12,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fepub%2Ftest_epub_processor.py%23L12-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code snippet tests an `EpubProcessor` class. It creates a `QuivrFile` object representing an EPUB file and processes it using the `EpubProcessor`. The assertion checks if the processor returns an empty list as a result.\n\n## Inputs\n\n* `p`: A `Path` object pointing to an EPUB file.\n* `uuid4()`: Generates two unique UUIDs for `id` and `brain_id`.\n* `processor`: An instance of the `EpubProcessor` class.\n* `f`: A `QuivrFile` object initialized with information about the EPUB file.\n\n## Output\n\n* `result`: An empty list.\n"
    },
    "tests__processor__odt__test_odt__test_odt_processor": {
        "label": "test_odt_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/odt/test_odt.py",
        "relativePath": "backend/core/tests/processor/odt/test_odt.py",
        "lineNo": 12,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fodt%2Ftest_odt.py%23L12-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis\n\n**[Quick Summary]** \n\nThis code snippet simulates the processing of an ODT (OpenDocument Text) file using a custom processor. It creates a `QuivrFile` object representing the file, passes it to an `ODTProcessor`, and asserts that the returned result is not empty. Likely, this is a test case for validating the ODT processing functionality.\n\n**[Inputs]**\n\n*  `p`: Path object pointing to an ODT file named \"sample.odt\"\n*  `uuid4()`: Generates two unique UUIDs used as identifiers for the file in the `QuivrFile` object.\n*  `\"\"`:  An empty string indicating the file extension of the input file.\n\n**[Output]**\n\n*  `result`: A potentially lengthy list of processed data produced by the `ODTProcessor` object. The content of this list is expected to be non-empty,  indicating successful processing. \n\n\n\n\n"
    },
    "tests__processor__test_default_implementations__test___build_processor": {
        "label": "test___build_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_default_implementations.py",
        "relativePath": "backend/core/tests/processor/test_default_implementations.py",
        "lineNo": 8,
        "endLineNo": 22,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_default_implementations.py%23L8-L22&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary \n\nThis code snippet defines a new processor class named \"TestCLS\" that is derived from a base processor class likely intended for handling text data. It specifically leverages the `BaseLoader` class for loading files with the \".txt\" extension. The purpose of this code is to instantiate and test the newly defined \"TestCLS\" processor instance.\n\n## Inputs\n\n* `_build_processor`: Likely a function that dynamically constructs a new processor class based on provided arguments.\n*  \"TestCLS`: A string representing the desired name of the new class.\n* `BaseLoader`: A base processor class presumably responsible for loading documents.\n* `[FileExtension.txt]`: A list of file extensions this new processor will support, specifically \".txt\" in this case.\n\n## Output\n\n*  `cls`: An instance of the newly created \"TestCLS\" processor class.\n*  Assertions: These validate various aspects of the `cls` object, such as its name, inheritance, attributes, and supported file extensions. \n* `proc`: An instance of the \"TestCLS\" processor, used to further verify its properties and functionality. \n\n\n"
    },
    "quivr_core__brain__info__BrainInfo__to_tree": {
        "label": "to_tree",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 61,
        "endLineNo": 74,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L61-L74&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**Quick Summary:**\n\nThis function constructs a hierarchical tree-like data structure (`tree`) representing information about a specific brain. It categorizes this information into sections like ID, Name, Files, Chats, and LLM, adding relevant details to each section. This structure likely serves as a visual or structured representation for displaying  brain-related data.  \n\n**Inputs:**\n\n* `self.brain_id`: Likely a string containing a unique identifier for the brain.\n* `self.brain_name`: Likely a string containing the name of the brain.\n* `self.files_info`: An object (potentially another class) containing information about files associated with the brain.\n* `self.chats_info`: An object (potentially another class) containing information about chats related to the brain.\n* `self.llm_info`: An object (potentially another class) containing information about the Large Language Model connected to the brain.\n\n\n**Output:**\n\n* `tree`: A hierarchical data structure representing the brain information. \n"
    },
    "tests__processor__test_registr__test__import_class": {
        "label": "test__import_class",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 124,
        "endLineNo": 137,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L124-L137&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**\n\nThis Python code defines a function `_import_class` (not shown in the snippet) that aims to import a class from a given module path and verifies its type. It also uses assertions and pytest to check if the imported class is correct and to raise specific exceptions for incorrect inputs. \n\n**[Inputs]**\n\n* `mod_path`: A string representing the path to the module containing the desired class. \n\n**[Output]**\n\n*  An imported class object if `mod_path` points to a valid class within a module.\n* Raises `TypeError` with a specific message if:\n    * `mod_path` doesn't point to a class.\n    * `mod_path` points to a module, not a class.\n\n\n\n"
    },
    "tests__test_brain__test_brain_ask_streaming": {
        "label": "test_brain_ask_streaming",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 116,
        "endLineNo": 129,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L116-L129&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Okay, here's a breakdown of the code snippet:\n\n**Quick Summary**\n\nThis function tests the functionality of a `Brain` object, which seems to be a custom class designed for interacting with a language model (LLM). It loads a brain from a file, asks a question, and verifies that the LLM's response matches a predefined answer.\n\n**Inputs**\n\n*  `fake_llm`:  Likely a simulated or placeholder LLM object used in testing.\n*  `embedder`:  An object responsible for converting text into numerical representations (embeddings).\n*  `temp_data_file`: A file containing data used to initialize the `Brain`.\n*  `answers`: A list of expected answers, likely corresponding to different questions. \n\n**Output**\n\n*  `response`: The text-based response generated by the `Brain` when asked the question.  \n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "tests__test_brain__test_brain_from_langchain_docs": {
        "label": "test_brain_from_langchain_docs",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 61,
        "endLineNo": 74,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L61-L74&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown\n\n**Quick Summary:**\n\nThis code creates a new instance of a \"Brain\" object using LangChain. It initializes the brain with a single document, an LLM, an embedder, and a memory vector store. It then asserts that the brain's storage is empty and its chat history is clear. This code likely aims to test the initial state of a Brain object before interacting with it.\n\n**Inputs:**\n\n*  `Document(\"content_1\", metadata={\"id\": uuid4()})` : A document object containing text (\"content_1\") and a unique ID.\n*  `name=\"test\"`:  A string name for the brain instance.\n*  `llm=fake_llm`: An instance of a language model (likely a placeholder in this case).\n*  `langchain_documents=[chunk]`: A list of documents to be used by the brain, containing the `chunk` document.\n*  `embedder=embedder`: An instance of an embedding model used to represent text as vectors.\n*  `vector_db=mem_vector_store`: A memory vector store (in this case, likely an in-memory store) to store document embeddings.\n\n\n\n**Output:**\n\n*  `length` of  `await brain.storage.get_files()`: This is expected to be 0, indicating an empty storage.\n*  `length` of `brain.chat_history`: This is expected to be 0, indicating no previous conversation history. \n\n\n*Let me know if you'd like a more in-depth explanation of any specific part!*\n"
    },
    "quivr_core__brain__brain__Brain__asearch": {
        "label": "asearch",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 228,
        "endLineNo": 240,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L228-L240&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown\n\n**Quick Summary:** \n\nThis asynchronous function performs a similarity search within a vector database (`self.vector_db`). It takes a query (either text or a Document object), retrieves the top `n_results` most similar documents along with their similarity scores, and efficiently fetches up to `fetch_n_neighbors` additional neighbors for each result. These results are then packaged into `SearchResult` objects and returned.  \n\n**Inputs:**\n* `query`: The search input, either a string or a Document object.\n* `n_results`: The desired number of top results to return.\n* `filter`: An optional filter function or dictionary to refine the search results.\n* `fetch_n_neighbors`: The maximum number of additional neighbors to fetch for each result.\n\n**Output:**\n\n* A list of `SearchResult` objects, where each object contains:\n    * `chunk`: The retrieved document (likely text).\n    * `distance`: The similarity score between the query and the document. \n\n\n\n"
    },
    "quivr_core__brain__brain_defaults__default_embedder": {
        "label": "default_embedder",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain_defaults.py",
        "relativePath": "backend/core/quivr_core/brain/brain_defaults.py",
        "lineNo": 33,
        "endLineNo": 45,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain_defaults.py%23L33-L45&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**[Quick summary]**\nThis function attempts to load and return an OpenAIEmbeddings object, which is used for embedding text into numerical vectors. If the  'langchain-openai' package is not installed, it raises an ImportError, suggesting the user install it or provide a compatible Embedder.\n\n**[Inputs]**\n\n- `logger`: Likely a logging object used for debugging and information output.\n\n**[Output]**\n\n- An instance of `OpenAIEmbeddings` if the package is successfully loaded.\n-  An `ImportError` if the 'langchain-openai' package is missing.  \n\n\n"
    },
    "quivr_core__chat__ChatHistory__append": {
        "label": "append",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 30,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L30-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**[Quick Summary]** This function takes a message (either from an AI or a human) and some optional metadata, and adds it to a list of messages associated with a specific chat.  This likely forms part of a larger chatbot system.\n\n**[Inputs]**\n* `langchain_msg`:  A message object from the LangChain library, representing either an AI's response or a user's input.\n* `metadata`: A dictionary of additional information about the message.\n\n**[Output]**\n*  The function appends a new `ChatMessage` object to the `self._msgs` list. This `ChatMessage` object will contain details about the message, including its ID, the chat it belongs to, and the provided metadata. \n"
    },
    "quivr_core__processor__implementations__tika_processor__TikaProcessor___send_parse_tika": {
        "label": "_send_parse_tika",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/tika_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/tika_processor.py",
        "lineNo": 41,
        "endLineNo": 53,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Ftika_processor.py%23L41-L53&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis \n\n**[Quick Summary]** This function attempts to send a text extraction request to a Tika server. It repeatedly tries to send the request up to a maximum number of retries, handling potential errors along the way. If all retries fail, it raises an error.\n\n**[Inputs]**\n\n* `self`:  Likely a reference to the class instance containing this function.\n* `f`: The content to be parsed by Tika, likely a string.\n* `self.max_retries`:  The maximum number of times to retry the request before failing.\n* `self._client`:  An HTTP client object used to communicate with the Tika server. \n* `tika_url`: The URL of the Tika server endpoint for text extraction.\n\n**[Output]**\n\n* A decoded string containing the extracted text from the input content 'f'. \n\n\n"
    },
    "quivr_core__quivr_rag__QuivrQARAG____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 48,
        "endLineNo": 60,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L48-L60&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function likely initializes a Retriever-Augmented Generation (RAG) system. RAG combines a large language model (LLM) with a vector store and a reranker to improve the quality and accuracy of LLM responses by retrieving relevant information from the vector store. \n\n## Inputs\n\n* `rag_config`: A configuration object likely specifying parameters for the RAG system.\n* `llm`: An instance of a LLM endpoint, enabling interaction with the language model.\n* `vector_store`: A storage system designed to efficiently store and retrieve vectorized embeddings of documents.\n* `reranker`:  An optional object responsible for rescoring the retrieved documents, potentially using compression techniques.  If not provided, it defaults to `IdempotentCompressor()`.\n\n## Output\n\n*  This function likely returns an instance of the RAG system itself, ready to be used for querying and generating text. \n"
    },
    "quivr_core__storage__local_storage__LocalStorage____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 14,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L14-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code snippet initializes a storage manager object responsible for handling local file operations related to Quivr. It defines the storage directory, initializes lists for managing files and their hashes, and sets a flag indicating whether files should be copied or not. The purpose is to provide a structured way to local files for efficient storage and retrieval.\n\n## Inputs\n* `dir_path`:  A string (optional) specifying the custom directory for file storage.\n* `copy_flag`: A boolean value determining whether files should be copied to the storage directory. \n\n\n## Output\n* An initialized `quivr_storage` object with attributes:\n    * `files`:  an empty list to store `QuivrFile` objects.\n    * `hashes`: an empty set to store file hashes.\n    * `dir_path`:  The path to the local storage directory.  \n"
    },
    "quivr_core__utils__format_history_to_openai_mesages": {
        "label": "format_history_to_openai_mesages",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 41,
        "endLineNo": 53,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L41-L53&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis function takes a history of chat interactions (human and AI messages as tuples) and a new user question, then formats them into a structured list of BaseMessages suitable for display or processing. The purpose is to organize conversational data for easier handling.\n\n\n## Inputs\n\n*  `tuple_history`: A list of tuples, each containing a human message and its corresponding AI response.\n*  `system_message`: A string representing an introductory message or system notification.\n*  `question`: A string containing the user's latest query.\n\n\n## Output\n\n*  `messages`: A list of BaseMessage objects. \n    * Each BaseMessage represents a single message in the conversation (either human or AI).\n"
    },
    "tests__conftest__chunks_stream_answer": {
        "label": "chunks_stream_answer",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 56,
        "endLineNo": 68,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L56-L68&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**Quick Summary**\n\nThis function reads JSON data from a file, parses each chunk, extracts an \"answer\" field if present, converts it to a specific `AIMessageChunk` object, and stores the processed chunks in a list. It likely prepares data for use in an AI model or system.\n\n**Inputs**\n\n* `\"./tests/chunk_stream_fixture.jsonl\"`: A path to a JSON Lines file containing data.\n  \n**Output**\n\n*  A list of processed dictionaries (chunks), each potentially containing an `AIMessageChunk` object within an \"answer\" field.  \n\n\n\n"
    },
    "tests__processor__odt__test_odt__test_odt_processor_fail": {
        "label": "test_odt_processor_fail",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/odt/test_odt.py",
        "relativePath": "backend/core/tests/processor/odt/test_odt.py",
        "lineNo": 29,
        "endLineNo": 41,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fodt%2Ftest_odt.py%23L29-L41&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code snippet simulates processing a file using a Quivr file object and an ODTProcessor.  It intentionally sets up a scenario where the file extension mismatch leads to a ValueError, testing the robustness of the processor.\n\n## Inputs\n\n* **`p = Path(\"./tests/processor/odt/bad_odt.odt\")`**:  A file path pointing to an OpenDocument Text (odt) file named \"bad_odt.odt.\"\n* **`f = QuivrFile(...)`**:  Creates a QuivrFile object representing the \"bad_odt.odt\" file with:\n    * `id`: A randomly generated UUID.\n    * `brain_id`: Another randomly generated UUID.\n    * `original_filename`: The filename without extension (\"bad_odt\").\n    * `path`: The file path.\n    * `file_extension`:  **`FileExtension.txt`** (intentionally wrong extension)\n    * `file_md5`:  Placeholder MD5 hash.\n* **`processor = ODTProcessor()`**:  Initializes an ODTProcessor object, likely responsible for processing ODT files.\n* **`await processor.process_file(f)`**: Calls the `process_file` method of the ODTProcessor, passing the `QuivrFile` object `f`.\n\n## Output\n\n* **`ValueError`**: The code expects a ValueError to be raised by the `process_file` method due to the mismatch between the specified file extension (`txt`) and the actual file type (odt).\n"
    },
    "tests__processor__pdf__test_megaparse_pdf_processor__test_megaparse_fail": {
        "label": "test_megaparse_fail",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/pdf/test_megaparse_pdf_processor.py",
        "relativePath": "backend/core/tests/processor/pdf/test_megaparse_pdf_processor.py",
        "lineNo": 37,
        "endLineNo": 49,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fpdf%2Ftest_megaparse_pdf_processor.py%23L37-L49&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Breakdown\n\n**Quick Summary:** This code snippet simulates an error scenario during file processing using a `MegaparseProcessor`. It creates a  `QuivrFile` object representing a PDF file and tries to process it, expecting a `ValueError` to be raised.  The purpose likely is to test error handling within the `MegaparseProcessor`.\n\n**Inputs:**\n\n* `p`: A `Path` object pointing to a sample PDF file (\"tests/processor/pdf/sample.pdf\").\n* `ext`:  A file extension (not shown, but implied).\n\n* `processor`: An instance of the `MegaparseProcessor` class.\n* `f`: A `QuivrFile` object constructed with:\n    * `id`: A unique UUID identifier.\n    * `brain_id`: Another unique UUID.\n    * `original_filename`: The filename from the `Path` object.\n    * `path`: The `Path` object itself.\n    * `file_extension`: The file extension\n    * `file_md5`:  A placeholder MD5 hash (\"123\").\n\n**Output:**\n\n*  A `ValueError` exception is expected to be raised by the `processor.process_file(f)` call. This implies that the `MegaparseProcessor` is not able to handle this particular `QuivrFile` object. \n\n\n\n\n"
    },
    "tests__processor__pdf__test_unstructured_pdf_processor__test_unstructured_pdf_processor_fail": {
        "label": "test_unstructured_pdf_processor_fail",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/pdf/test_unstructured_pdf_processor.py",
        "relativePath": "backend/core/tests/processor/pdf/test_unstructured_pdf_processor.py",
        "lineNo": 30,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fpdf%2Ftest_unstructured_pdf_processor.py%23L30-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:**\n\nThis code snippet simulates processing a PDF file using a `QuivrFile` object and a `UnstructuredPDFProcessor`.  It's designed to test the `process_file` method of the processor, specifically expecting a `ValueError` to be raised.  \n\n**Inputs:**\n\n* `p`: A `Path` object pointing to a sample PDF file.\n* `ext`: A file extension (e.g., \".pdf\").\n* `uuid4()`: This generates two unique UUIDs, likely for identifying the file and its associated brain data.\n* `processor`: An instance of `UnstructuredPDFProcessor`.\n\n**Output:**\n\n* `ValueError`: This exception is intentionally raised, indicating an issue with processing the PDF file. \n\n\n\nLet me know if you need further clarification on any aspect of the code.\n"
    },
    "tests__processor__test_simple_txt_processor__test_simple_processor": {
        "label": "test_simple_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_simple_txt_processor.py",
        "relativePath": "backend/core/tests/processor/test_simple_txt_processor.py",
        "lineNo": 22,
        "endLineNo": 34,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_simple_txt_processor.py%23L22-L34&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down this code snippet:\n\n**[Quick Summary]** \n\nThis code tests a text processing function (`SimpleTxtProcessor`). It checks if the processor only handles .txt files and ensures it correctly extracts text content from a test .txt file.  \n\n**[Inputs]**\n\n* `quivr_pdf`:  Likely a file object representing a PDF document.\n* `quivr_txt`: Likely a file object representing a plain text (.txt) document.\n* `SimpleTxtProcessor`: A class or object presumably designed for processing text files.\n\n**[Output]**\n\n* `ValueError`: This exception is expected when trying to process a PDF file with a function meant for text files.\n* `docs`: A list of processed documents, with at least one document containing the text \"This is some test data.\". \n\n\n"
    },
    "tests__test_llm_endpoint__test_llm_endpoint_from_config": {
        "label": "test_llm_endpoint_from_config",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_llm_endpoint.py",
        "relativePath": "backend/core/tests/test_llm_endpoint.py",
        "lineNo": 30,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_llm_endpoint.py%23L30-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary**\n\nThis Python code snippet configures and initializes a language model (LLM) using the LangChain framework and the Llama2 model. It then asserts that the initialized LLM object doesn't support function calling and that it's an instance of `ChatOpenAI`.\n\n**Inputs**\n\n* `model`: Specifies the name of the language model to be used (\"llama2\").\n* `llm_api_key`: Placeholder for an API key used to authenticate with the LLM service (\"test\").\n* `llm_base_url`: The base URL of the LLM service endpoint (\"http://localhost:8441\").\n\n**Output**\n\n* Assertion: `llm.supports_func_calling()` returns `False`\n* Assertion: `isinstance(llm._llm, ChatOpenAI)` returns `True`\n* Assertion:  `llm._llm.model_name` (extracted from the `ChatOpenAI` object) is present in `llm.get_config().model`\n\n\n"
    },
    "tests__test_utils__test_parse_chunk_response_nofunc_calling": {
        "label": "test_parse_chunk_response_nofunc_calling",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 45,
        "endLineNo": 57,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L45-L57&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "The code defines a function (presumably named `parse_chunk_response`, though not explicitly shown) that seems to be simulating a conversation or message processing loop. It iteratively appends content to a rolling message (`rolling_msg`) and checks if it matches the expected output from parsing a chunk of data.\n\n**Inputs:**\n\n*  `rolling_msg`: An object likely representing the accumulating conversation state (e.g., a chat history).\n* `chunk`: Another object, perhaps a single message or data structure, being processed.\n* `False`: A boolean flag, possibly indicating whether to perform some sort of special handling or validation.\n\n**Output:**\n\n* `rolling_msg`: The updated `rolling_msg` after the processing. \n* `parsed_chunk`: The extracted or parsed content from the `chunk`. \n\n\n"
    },
    "quivr_core__brain__info__LLMInfo__add_to_tree": {
        "label": "add_to_tree",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 31,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L31-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Certainly, let's break down the provided code snippet.\n\n**Quick Summary:**\n\nThis function constructs a structured representation (likely for display) of an LLM (Large Language Model) instance. It gathers key attributes like the model name, base URL, temperature setting, maximum token limit, and whether the model supports function calls.  The output is probably intended for visualization or documentation purposes.\n\n**Inputs:**\n\n- `self.model`: The name or identifier of the LLM.\n- `self.llm_base_url`:  The base URL for interacting with the LLM API.\n- `self.temperature`: A parameter controlling the randomness or creativity of the LLM's output.\n- `self.max_tokens`:  The maximum number of tokens (words or subwords) the LLM can generate in a response.\n- `self.supports_function_calling`: A boolean indicating whether the LLM allows function calls within prompts.\n\n**Output:**\n\n- A structured representation (likely a tree or similar data structure) containing the above LLM attributes, formatted with Markdown-like styling for emphasis. \n\n\n\nLet me know if you have any more code snippets you'd like analyzed!\n\n"
    },
    "quivr_core__models__QuivrKnowledge": {
        "label": "QuivrKnowledge",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 85,
        "endLineNo": 96,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L85-L96&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis \n\n[**Quick Summary**]\nThis code defines a Pydantic model, likely used for data validation and serialization. It represents information about a file being processed, including its unique identifier, association with a \"brain\" (potentially a knowledge base), file metadata, and processing status. \n\n[**Inputs**]\n\n*  `id`:  A unique identifier for the file.\n*  `brain_id`:  A unique identifier for the knowledge source or \"brain\" associated with this file.\n*  `file_name`:  The optional name of the file.\n*  `url`:  An optional URL pointing to the file location.\n*  `extension`: The file extension (defaults to \"txt\").\n*  `status`: The current processing status (defaults to \"PROCESSING\").\n*  `integration`: An optional string indicating the integration system used.\n*  `integration_link`: An optional link related to the integration system.\n\n[**Output**]\n\n*  A validated and structured object representing the file information, ready for use in a LangChain application or other system. \n\n\n"
    },
    "tests__processor__test_registr__test_register_new_proc_append": {
        "label": "test_register_new_proc_append",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 156,
        "endLineNo": 167,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L156-L167&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis: \n\n**[Quick summary]**\n\nThis code snippet tests the `register_processor` function, which likely manages a registry of file processors based on their extensions. It checks if a new processor is added when the file extension doesn't already exist and verifies that a warning message is logged if the processor already exists. \n\n**[Inputs]**\n\n* `known_processors`: A dictionary or similar data structure storing registered file processors, likely keyed by file extensions.\n* `FileExtension.txt`: Represents a specific file extension (e.g., \".txt\") used as a key in `known_processors`.\n* `\"test.\"`:  This is likely the name or identifier of the new file processor being registered.\n* `append=True`: A boolean flag indicating whether the new processor should be added to the existing processors associated with the extension.\n* `caplog`: A tool used for capturing log messages, likely from the `logging` module.\n* `logging.INFO`:  The logging level at which messages should be captured.\n\n**[Output]**\n\n*  Increased count of processors associated with `\"FileExtension.txt\"`  in `known_processors` when the processor is new.\n* A specific log message (\"test. already in registry...\") at the `logging.INFO` level from the logger \"quivr_core\" when the processor already exists. \n\n\n\n"
    },
    "tests__test_quivr_rag__mock_chain_qa_stream": {
        "label": "mock_chain_qa_stream",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_quivr_rag.py",
        "relativePath": "backend/core/tests/test_quivr_rag.py",
        "lineNo": 12,
        "endLineNo": 23,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_quivr_rag.py%23L12-L23&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code mocks the functionality of a `QuivrQARAG` class, specifically replacing its `build_chain` method with a custom function `mock_qa_chain`. This mocking is done using `monkeypatch`, likely for testing purposes to isolate the `QuivrQARAG` class's usage.\n\n## Inputs\n\n- `QuivrQARAG`: Class being mocked\n\n- `monkeypatch`:  Library used to patch methods and attributes likely from the `pytest` library\n\n- `chunks_stream_answer`: A list or iterable of data likely representing a stream of answers\n\n- `build_chain`: Original method of the `QuivrQARAG` class that is being stubbed\n\n\n## Output\n\n- A mocked `QuivrQARAG` object where the `build_chain` method returns an instance of `MockQAChain`.\n- `MockQAChain`: An object that simulates the streaming of answers from `chunks_stream_answer`. \n"
    },
    "quivr_core__chat__ChatHistory__get_chat_history": {
        "label": "get_chat_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 16,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L16-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function sorts a list of `ChatMessage` objects by their `message_time` attribute. It allows the user to select whether to return the messages in ascending (oldest first) or descending (newest first) order. \n\n**Inputs:**\n\n* `self._msgs`:  A list of `ChatMessage` objects presumably stored as a class attribute.\n* `newest_first`: A boolean flag indicating whether to sort by newest message first.\n\n**Output:**\n\n* A sorted list of `ChatMessage` objects. \n \n"
    },
    "quivr_core__chat__ChatHistory__iter_pairs": {
        "label": "iter_pairs",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 43,
        "endLineNo": 53,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L43-L53&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function iterates through the chat history, retrieving both human and AI messages. It ensures that the messages are of the expected types (HumanMessage and AIMessage) and yields pairs of human and AI messages. The purpose is likely to process the chat history, possibly for analysis or training purposes.\n\n## Inputs:\n\n* `self`: A reference to the object containing the chat history.\n\n## Output:\n\n*  Pairs of `(human_message, ai_message)` tuples, iterating through the chat history newly"
    },
    "quivr_core__processor__implementations__simple_txt_processor__SimpleTxtProcessor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "lineNo": 45,
        "endLineNo": 55,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fsimple_txt_processor.py%23L45-L55&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function reads a file asynchronously, converts its contents into a Document object, and then splits that document into smaller chunks using a recursive character-based splitting algorithm. The purpose is likely to break down large documents into manageable pieces for processing, which could be beneficial for tasks like text analysis or parallel processing.\n\n## Inputs\n\n* `file`: Likely an object representing a file on the system.\n* `self.splitter_config`: Likely a configuration object containing parameters for the document splitting process, possibly including:\n    * `chunk_size`:  The desired size of each document chunk.\n    * `chunk_overlap`: The amount of overlap allowed between consecutive chunks.\n\n## Output\n\n* `docs`: A list of Document objects, each representing a smaller chunk of the original document. \n\n\n"
    },
    "tests__conftest__quivr_pdf": {
        "label": "quivr_pdf",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 39,
        "endLineNo": 49,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L39-L49&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**[Quick Summary]**\n\nThis function generates a `QuivrFile` object, which likely represents a file within a system. It assigns a unique ID, file extension, MD5 hash, and a path to a dummy PDF file. This code might be used for testing or mocking file-related operations. \n\n**[Inputs]**\n\n* `uuid4()`: Generates random, universally unique identifiers (UUIDs) for the `id` and `brain_id` fields.\n* `original_filename`: Set to \"dummy.pdf\", indicating the original name of the file.\n* `path`: Points to the file \"dummy.pdf\" located within the \"tests/processor/data\" directory.\n* `FileExtension.pdf`: Represents the file extension as PDF.\n* `file_md5`: A placeholder MD5 hash value \"13bh234jh234\".\n\n**[Output]**\n\n* A `QuivrFile` object with the specified attributes. \n\n\n\nLet me know if you have any other code snippets you'd like me to analyze."
    },
    "tests__conftest__quivr_txt": {
        "label": "quivr_txt",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 27,
        "endLineNo": 37,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L27-L37&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary \n\nThis function creates a new `QuivrFile` object.  It populates the object with details about a temporary data file, including a unique identifier, a brain ID, original filename, file path, file extension, and a placeholder MD5 hash. \n\n## Inputs\n\n* `temp_data_file`: This is likely a file object representing a temporary file that has been uploaded or created within the application.\n\n ## Output\n\n* A `QuivrFile` object containing the following attributes:\n    * `id`: A unique UUID assigned to the file.\n    * `brain_id`: A UUID associated with the \"brain\" which could refer to a user, a dataset, or a specific processing context.\n    * `original_filename`: The original filename of the temporary data file.\n    * `path`: The file path to the temporary data file.\n    * `file_extension`: Set to `.txt`, indicating the file type is text.\n    * `file_md5`: A placeholder value \"123\" which should ideally be replaced with the actual MD5 hash of the file content for integrity verification. \n\n\n"
    },
    "tests__processor__test_registr__test_get_default_processors_cls": {
        "label": "test_get_default_processors_cls",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 27,
        "endLineNo": 37,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L27-L37&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown:\n\n**[Quick summary]** This code snippet tests a function `get_processor_class` which dynamically determines the appropriate class to process files based on their extension. It verifies that the function correctly identifies `TikTokenTxtProcessor` for `.txt` files and `TikaProcessor` for `.pdf` files. \n\n **[Inputs]**\n*  `FileExtension`:  An enum or class representing different file extensions like `.txt`, `.pdf`.\n\n**[Output]**\n*  `cls`: A class object representing the processor suitable for handling the specified file extension. \n"
    },
    "tests__processor__test_txt_processor__txt_qfile": {
        "label": "txt_qfile",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_txt_processor.py",
        "relativePath": "backend/core/tests/processor/test_txt_processor.py",
        "lineNo": 9,
        "endLineNo": 19,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_txt_processor.py%23L9-L19&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown\n\n**Quick Summary:** This function generates a `QuivrFile` object representing a temporary text file.  It assigns a unique ID, a brain ID, and other metadata to the file instance. This likely serves as a placeholder or data structure for managing temporary files within a larger application.\n\n**Inputs:**\n\n* `temp_data_file`: A file path pointing to a temporary file.\n\n**Output:**\n\n* A `QuivrFile` object with the following attributes:\n   * `id`:  A randomly generated UUID.\n   * `brain_id`: A randomly generated UUID.\n   * `original_filename`: The filename \"data.txt\"\n   * `path`: The `temp_data_file` path.\n   * `file_extension`:  `FileExtension.txt`, indicating a text file.\n   * `file_md5`: The string \"hash\", likely representing the MD5 hash of the file content. \n\n\n\n"
    },
    "tests__test_brain__test_brain_empty_files": {
        "label": "test_brain_empty_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 26,
        "endLineNo": 36,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L26-L36&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown:\n\n**Quick Summary:**\n\nThis code snippet initializes a \"brain\" object, likely representing a knowledge base or AI agent, using a pre-trained language model (`fake_llm`), an embedding model (`embedder`), and a memory-based vector store (`mem_vector_store`). The `from_files` method suggests that the brain's initial knowledge might be loaded from external files, though the `file_paths` are currently empty.  \n\n **Inputs:**\n\n*  `name`:  The desired name for the brain object (e.g., \"test_brain\").\n* `file_paths`: A list of paths to files containing initial data for the brain. Currently empty.\n* `llm`: A pre-trained language model likely used for understanding and generating text.\n* `embedder`: A model that converts text into numerical vectors for storage and retrieval in the vector database.\n* `mem_vector_store`: A memory-based vector database used to store and access knowledge represented as text embeddings.\n\n**Output:**\n\n* A `brain` object, potentially ready for further training or interaction. \n* The `assert brain` statement checks if the brain object was successfully created and will raise an error if not.  \n\n\n\n"
    },
    "tests__test_brain__test_brain_empty_files_no_vectordb": {
        "label": "test_brain_empty_files_no_vectordb",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_brain.py",
        "relativePath": "backend/core/tests/test_brain.py",
        "lineNo": 15,
        "endLineNo": 25,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_brain.py%23L15-L25&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis of Python Code Snippet\n\n**Quick Summary:** This code tests the `Brain.from_files` function, which is likely designed to initialize a  brain-like object from files containing model weights, by ensuring an error is raised when no file paths are provided.\n\n**Inputs:**\n\n* `name`:  A string specifying the name of the brain being created.\n* `file_paths`: A list of strings, expected to contain paths to files with model data.  \n* `llm`: An object presumably representing a Large Language Model.\n* `embedder`: An object likely responsible for embedding text.\n\n**Output:**\n\n* A `ValueError` exception should be raised. \n\n\n\n\n"
    },
    "tests__test_chat_histor__test_chat_history_iter_pais": {
        "label": "test_chat_history_iter_pais",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 67,
        "endLineNo": 77,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L67-L77&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Okay, here's a breakdown of the code snippet:\n\n**Quick Summary**\n\nThe code demonstrates the creation and usage of a ChatHistory object, which likely represents a conversational log between a human and an AI.  It populates this history with messages and then extracts pairs of human and AI messages.\n\n**Inputs**\n\n* `human_message`: A string representing a message generated by a human.\n* `ai_message`: A string representing a message generated by an AI.\n\n**Output**\n\n* `result`: A list of tuples, where each tuple contains a human message paired with the corresponding AI message.  \n\nLet me know if you have any more code snippets you'd like me to analyze! \n\n"
    },
    "quivr_core__brain__brain_defaults__default_llm": {
        "label": "default_llm",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain_defaults.py",
        "relativePath": "backend/core/quivr_core/brain/brain_defaults.py",
        "lineNo": 46,
        "endLineNo": 55,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain_defaults.py%23L46-L55&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**[Quick Summary]** This function attempts to load a language model (LLM) named \"ChatOpenAI\" as the default LLM for a system called \"brain\". If successful, it returns the loaded LLM object. If the required package is not found, it raises an ImportError.\n\n**[Inputs]**\n\n*  `logger`: Likely a logging object used for recording messages during the process.\n*  `LLMEndpointConfig()`: An object likely containing settings and configuration parameters for the \"ChatOpenAI\" LLM.\n\n**[Output]**\n\n*  `llm`:  An object representing the loaded \"ChatOpenAI\" LLM. \n*  `ImportError`: Raised if the required package or configuration is missing.\n\n\n\n\n"
    },
    "quivr_core__brain__info__ChatHistoryInfo__add_to_tree": {
        "label": "add_to_tree",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 13,
        "endLineNo": 22,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L13-L22&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:** This function appears to be updating a tree-like structure (`chats_tree`) with information about chat settings.  It displays the total number of chats, the currently active default chat, and the length of the chat history for the active chat.\n\n**Inputs:**\n\n*  `self.nb_chats`: likely an integer representing the total number of chats available\n*  `self.current_default_chat`: probably a string holding the name or identifier of the currently selected default chat\n*  `self.current_chat_history_length`: likely an integer indicating the number of messages in the history of the active chat\n\n**Output:**\n\n* Updates the `chats_tree` structure with formatted strings containing:\n    * Total number of chats\n    * Name of the current default chat\n    * Length of the current chat history \n\n\n\n"
    },
    "quivr_core__config__LLMEndpointConfig": {
        "label": "LLMEndpointConfig",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/config.py",
        "relativePath": "backend/core/quivr_core/config.py",
        "lineNo": 4,
        "endLineNo": 13,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fconfig.py%23L4-L13&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick summary]** This code defines the parameters for interacting with a large language model (LLM). It likely sets up a function to send text input to an LLM API, control the amount of input and output, manage the model's \"creativity\" (temperature), and potentially handle streaming responses. The purpose is to configure and streamline communication with a specific LLM.\n\n**[Inputs]**\n\n* `model`: The name or identifier of the chosen LLM (e.g., \"gpt-3.5-turbo-0125\").\n* `llm_base_url`:  The base URL for the LLM API.\n* `llm_api_key`: An API key required for authentication with the LLM.\n* `max_input`:  The maximum number of tokens allowed in the input text.\n* `max_tokens`: The maximum number of tokens allowed in the LLM's output.\n* `temperature`: A value controlling the randomness and creativity of the LLM's responses (higher = more creative).\n* `streaming`: A boolean indicating whether to receive the LLM's response in a streaming fashion (True) or as a complete string (False).\n\n**[Output]**\n\n*  The output likely involves a function call that utilizes the defined parameters to send text to the LLM and receive a generated response.\n  \n\n\n\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint__info": {
        "label": "info",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 62,
        "endLineNo": 71,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L62-L71&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**[Quick Summary]**\n\nThis function likely retrieves and structures information about a large language model (LLM) based on configuration settings. It prepares this information into an object called `LLMInfo`, which can be used to represent and interact with the LLM.\n\n**[Inputs]**\n\n*  `self._config`:  An object containing configuration parameters for the LLM, likely including:\n    *  `model`: The name or identifier of the specific LLM.\n    *  `llm_base_url`: A base URL for interacting with the LLM (could be OpenAI's API, for example).\n    *  `temperature`: A parameter controlling the randomness of the LLM's output.\n    *  `max_tokens`:  A limit on the number of tokens (words or subword units) the LLM can generate in a response.\n\n**[Output]**\n\n* `LLMInfo` object: \n    * `model`: The name or identifier of the LLM.\n    * `llm_base_url`:  The base URL for interacting with the LLM.\n    * `temperature`: The temperature parameter.\n    * `max_tokens`: The maximum number of tokens allowed in a response.\n    * `supports_function_calling`: A boolean indicating whether the LLM supports function calls. \n\n\n\n"
    },
    "quivr_core__quivr_rag__IdempotentCompressor": {
        "label": "IdempotentCompressor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 37,
        "endLineNo": 46,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L37-L46&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis function `compress_documents` is intended to compress a collection of documents based on a provided query. However, the current implementation simply returns the original documents without any compression, indicating a placeholder or incomplete logic.\n\n[Inputs]\n* `documents`: A sequence (e.g., list or tuple) containing `Document` objects. These represent the text documents to be compressed.\n* `query`: A string that specifies the criteria or context for compression.\n* `callbacks`: An optional `Callbacks` object, possibly for handling progress or events during compression.\n\n[Output]\n* `Sequence[Document]`: A sequence of `Document` objects, which should ideally be the compressed versions of the input documents based on the query. \n\n\n"
    },
    "quivr_core__utils__combine_documents": {
        "label": "combine_documents",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 137,
        "endLineNo": 146,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L137-L146&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Breakdown \n\n**Quick Summary:**\n\nThis function formats a list of documents, adding metadata with an index for each document and preparing them for input into a language model by wrapping them in a pre-defined prompt structure. The purpose is to structure documents for processing by a language model, allowing for citation and context within the prompt.\n\n**Inputs:**\n\n*  `docs`: A list of  documents (likely `Document` objects).\n*  `document_prompt`: A string that serves as a prompt template for each document.\n*  `document_separator`: A string used to separate individual documents in the final output.\n\n**Output:**\n\n* A single string containing all the formatted documents, each preceded by the `document_prompt` and separated by the `document_separator`. \n\n\n"
    },
    "quivr_core__utils__get_prev_message_str": {
        "label": "get_prev_message_str",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 79,
        "endLineNo": 88,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L79-L88&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:** This function searches through a list of tool calls within a message (`msg.tool_calls`) to find a specific call that meets certain criteria. If found, it extracts the answer from that tool call's arguments. Otherwise, it returns an empty string. This suggests the purpose is to retrieve a tool-provided answer from a structured message.\n\n**Inputs:**\n* `msg`: Likely a message object containing information about a conversation or interaction.\n* `cited_answer_filter`:  A function used to determine if a tool call should be considered for extracting the answer.\n\n**Output:**\n* A string containing the answer extracted from a tool call's arguments if found, or an empty string otherwise. \n\n\nLet me know if you need more details or have other code snippets you'd like analyzed!\n"
    },
    "tests__processor__test_registr__test_register_override_error__TestProcessor": {
        "label": "TestProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 212,
        "endLineNo": 221,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L212-L221&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code defines a blueprint for processing files, specifically PDF files, within a larger system. It outlines the file extensions the processor handles, provides metadata about the processor, and defines a method to process the actual file content, although this method currently returns an empty list. The purpose is to establish a framework for handling PDF files in a structured and extensible way.\n\n\n## Inputs\n\n* **`self`:**  Refers to the instance of the class this code belongs to. \n* **`file: QuivrFile`:**  An instance of a custom `QuivrFile` object, likely containing information about the PDF file being processed.\n\n## Output\n\n* **`return []`:** An empty list. Currently, this indicates that no documents are extracted from the PDF file. This suggests that the `process_file_inner` method needs further implementation to actually parse and process the PDF content.  \n"
    },
    "tests__processor__test_registr__test_register_override_proc__TestProcessor": {
        "label": "TestProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 193,
        "endLineNo": 202,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L193-L202&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:**\n\nThis code defines a base class for processing files, specifically PDFs in this case.  It sets up expected file extensions and a placeholder for metadata about the processor.  An `async process_file_inner` method is defined, which, when implemented in subclasses, will handle the actual PDF processing logic and return a list of extracted documents.\n\n**Inputs:**\n\n* `file: QuivrFile`:  An instance of the `QuivrFile` class representing the PDF file to be processed.\n\n**Output:**\n\n* `list[Document]`: A list of `Document` objects, likely representing extracted text, images, or other content from the PDF.\n\n\n"
    },
    "tests__test_chat_histor__test_chat_history_iter_pairs_invalid": {
        "label": "test_chat_history_iter_pairs_invalid",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 57,
        "endLineNo": 66,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L57-L66&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick summary]\n\nThis function tests whether a `ChatHistory` object correctly recognizes and raises an `AssertionError` when two identical AI messages are appended consecutively. The purpose is to ensure the chat history maintains a unique sequence of message pairs and flags potential errors in data structures.\n\n\n[Inputs]\n- `ai_message`: An instance of the `AIMessage` class, representing a message generated by an AI.\n- `human_message`: An instance of the `HumanMessage` class, representing a message from a human user.\n\n[Output]\n- Raises an `AssertionError`: This indicates that the test case is successful as the `ChatHistory` object has identified the duplicate AI message. \n\n\n\n"
    },
    "quivr_core__brain__info__StorageInfo": {
        "label": "StorageInfo",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 44,
        "endLineNo": 52,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L44-L52&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function takes a `files_tree` object (likely representing a hierarchical file structure) and adds two pieces of information to it: the \"Storage Type\" and \"Number of Files\" attributes of the object it belongs to.  It aims to populate a file directory representation.\n\n**Inputs:**\n\n* `self`:  A reference to the object itself, likely a class instance.\n* `files_tree`: An object of a class named `Tree`, presumably designed to represent and manipulate a tree-like data structure. \n\n**Output:**\n\n* Modifies the `files_tree` object by adding two nodes:\n    * One displaying the \"Storage Type\" with italic formatting.\n    * Another displaying the \"Number of Files\" with bold formatting. \n"
    },
    "quivr_core__chat_llm__ChatLLM__answer": {
        "label": "answer",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 90,
        "endLineNo": 98,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L90-L98&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**[Quick Summary]** This function parses a response from a large language model (LLM) after it interacts with a user's question and potentially previous chat history. It utilizes a configured chain of LLMs and a parsing function to format the response for consumption.\n\n**[Inputs]**\n\n* `question: str`:  The user's query input as text.\n* `history: ChatHistory | None = None`:  Previous interactions in the chat, potentially used for context.\n\n**[Output]**\n\n* `ParsedRAGResponse`: A structured representation of the LLM's response, likely including relevant information extracted and formatted for clarity.  \n\n\n\n"
    },
    "quivr_core__models__ChatLLMMetadata": {
        "label": "ChatLLMMetadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 58,
        "endLineNo": 66,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L58-L66&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "You provided a code snippet that defines a Python class, not a function. \n\nHere's a breakdown:\n\n**[Quick summary]**\nThis code defines a Python class, likely representing an AI model or agent. The class stores information about the model, such as its name, display name, description, image URL, and associated brain (potentially another AI model). \n\n**[Inputs]**\n*  Not applicable to a class definition. Classes define blueprints for objects, not functions that take inputs.\n\n**[Output]**\n\n*  Not applicable to a class definition.\n*  Classes can be used to create objects (instances) that have attributes and methods. \n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "quivr_core__models__ChatMessage": {
        "label": "ChatMessage",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 31,
        "endLineNo": 39,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L31-L39&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis \n\n**Quick Summary:**\nThis code snippet defines a data structure, likely a class, representing a message in a chat application. Each message is associated with a unique identifier (chat_id, message_id), potentially linked to a brain (model) instance (brain_id), the message content (AIMessage or HumanMessage), the time it was sent, and arbitrary metadata. This structure is used to organize and manage messages within the chat application.\n\n\n**Inputs:**\n *  `chat_id`:  Unique identifier of the chat the message belongs to.\n * `message_id`: Unique identifier of the individual message.\n * `brain_id`:  Optional identifier of the AI model that generated the message (if applicable).\n * `msg`:  The actual message content, classified as either an `AIMessage` or `HumanMessage`.\n * `message_time`:  Datetime indicating when the message was sent.\n * `metadata`:  Any additional information associated with the message.\n\n**Output:**\n*  A structured representation of a chat message, ready to be stored, processed, or transmitted. \n"
    },
    "quivr_core__processor__implementations__megaparse_processor__MegaparseProcessor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "lineNo": 48,
        "endLineNo": 56,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fmegaparse_processor.py%23L48-L56&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function processes text documents obtained from a MegaParse object. It splits long documents into smaller chunks based on a specified chunk size, adding metadata about the chunk size to each document.  \n\n## Inputs\n\n*  `file.path`: A path to a file.\n*  `self.megaparse_kwargs`: Keyword arguments for the MegaParse object initialization.\n*  `self.splitter_config.chunk_size`: An integer defining the maximum size of each text chunk.\n*  `self.enc`: An encoding object likely used for calculating the chunk size. \n\n## Output\n\n* A list of Document objects, potentially consisting of one or multiple documents. Each document may have additional metadata indicating the chunk size it covers. \n\n\n"
    },
    "quivr_core__quivr_rag__IdempotentCompressor__compress_documents": {
        "label": "compress_documents",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 38,
        "endLineNo": 46,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L38-L46&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary] \nThis function appears to be a placeholder or a stub function designed to return a list of documents unchanged.  It likely simulates some search functionality without actually performing any search logic. The purpose might be for testing or demonstration, where the focus is on the interaction pattern rather than the search algorithm itself.\n\n[Inputs]\n*  `documents`: A sequence (like a list) of objects presumably representing documents. \n*  `query`: A string, likely meant to be a search query.\n*  `callbacks`: An optional collection of functions to be called during the search process (if implemented).\n\n[Output]\n* A sequence of `Document` objects, which is the same input list of documents unchanged.  \n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "quivr_core__utils__format_file_list": {
        "label": "format_file_list",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 147,
        "endLineNo": 155,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L147-L155&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the provided Python code:\n\n**[Quick Summary]** \n\nThis function takes an array of QuivrKnowledge objects (likely representing files) and limits the output to a maximum of `max_files`. It then returns a string containing the file names or URLs, separated by newlines. If the input array is empty, it returns \"None\". \n\n**[Inputs]**\n\n* `list_files_array`: An array of `QuivrKnowledge` objects, each containing either a `file_name` or a `url`.\n* `max_files`: An integer representing the maximum number of files to include in the output string.\n\n**[Output]**\n\n*  A string containing a list of file names or URLs, separated by newlines. \n   * If the input array is empty, the output is \"None\". \n\n\n"
    },
    "tests__processor__test_simple_txt_processor__test_recursive_character_splitter": {
        "label": "test_recursive_character_splitter",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_simple_txt_processor.py",
        "relativePath": "backend/core/tests/processor/test_simple_txt_processor.py",
        "lineNo": 12,
        "endLineNo": 20,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_simple_txt_processor.py%23L12-L20&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis code snippet demonstrates the behavior of a function called `recursive_character_splitter`.  It takes a `Document` object, splits its content into chunks based on character boundaries, and ensures metadata is carried along with each chunk. This likely simulates a chunking strategy for text processing.\n\n## Inputs\n\n*  `doc`: A `Document` object containing page content and metadata.\n* `chunk_size`:  An integer specifying the desired size of each character chunk.\n* `chunk_overlap`: An integer indicating the amount of overlap between consecutive chunks.\n\n## Output\n\n* A list of `Document` objects, each containing a portion of the original `doc`'s content.\n* Each new `Document` object retains the original metadata from the input `doc`. \n"
    },
    "tests__test_chat_histor__test_chat_history_append": {
        "label": "test_chat_history_append",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 29,
        "endLineNo": 37,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L29-L37&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**[Summary]**\n\nThis code snippet demonstrates the basic functionality of a `ChatHistory` object. It creates a chat history, appends messages from both an AI and a human user, and asserts the correct length of the history after each append operation.  The purpose is likely to test the functionality of the `ChatHistory` class.\n\n**[Inputs]**\n\n*  `chat_history`: An object of type `ChatHistory`, presumably already initialized. \n*  `ai_message`: A string representing a message from an AI.\n*  `human_message`: A string representing a message from a human user.\n\n**[Output]**\n\n* The code asserts that the length of the `chat_history` object is 1 after appending the AI message, and 2 after appending the human message. \n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "tests__test_chat_histor__test_chat_history_constructor": {
        "label": "test_chat_history_constructor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 20,
        "endLineNo": 28,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L20-L28&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick summary]\nThis code snippet creates a new instance of a `ChatHistory` object, associating it with a unique brain ID and chat ID. It then verifies that these IDs are correctly assigned and that the initial chat history is empty. The purpose is likely to initialize a new chat session and store its history.\n\n[Inputs]\n- `uuid4()`: A function call that generates a universally unique identifier (UUID) for the brain and chat.\n\n[Output]\n- An instance of `ChatHistory` object\n- Assertions confirming that the brain_id, chat_id, and initial message count are as expected. \n\n\n"
    },
    "tests__test_utils___check_rolling_msg": {
        "label": "_check_rolling_msg",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 58,
        "endLineNo": 66,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L58-L66&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function checks if a message from a Role Playing (ROL) system requests a \"cited answer\" from a tool. It verifies if the message contains a tool call named \"cited_answer\" with arguments, specifically looking for an \"answer\" key within those arguments. \n\n## Inputs\n* **rol_msg:**  A message object likely containing information about a conversation or interaction within the ROL system.\n\n## Output\n* **True:** If the message requests a cited answer from a tool.\n* **False:** If the message does not meet the specified criteria. \n\n\n"
    },
    "tests__test_utils__test_get_prev_message_incorrect_message": {
        "label": "test_get_prev_message_incorrect_message",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 19,
        "endLineNo": 27,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L19-L27&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Analysis \n\n**Quick Summary:**\nThis code snippet appears to test the function `get_prev_message_str`, which presumably retrieves a previous message string from an AIMessageChunk object. The test case specifically checks if the function returns an empty string when called on a chunk with no previous message content.\n\n**Inputs:**\n\n* `chunk`: An object of type `AIMessageChunk`.\n    \n* `chunk.content`: An empty string indicating no previous message content.\n* `chunk.tool_calls`: A list containing a single `ToolCall` object, likely used for tool interactions within the AIMessageChunk context. \n\n**Output:**\n\n*  `get_prev_message_str(chunk)` should return an empty string. \n* `pytest.raises(StopIteration)`: This assertion verifies that the function raises a `StopIteration` exception, suggesting that there are no previous messages available.  \n\n\nLet me know if you'd like me to elaborate on any specific aspect of the code!\n"
    },
    "quivr_core__files__file__QuivrFile__metadata": {
        "label": "metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 121,
        "endLineNo": 128,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L121-L128&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function likely processes a file object and compiles information about it into a dictionary. This dictionary probably represents the file's metadata for storage or transmission.\n\n**Inputs:**\n*  `self.id`:  A unique identifier for the file.\n*  `self.path`: The location of the file on the system.\n*  `self.original_filename`: The original, user-provided name of the file.\n*  `self.file_md5`:  The MD5 hash of the file contents.\n*  `self.file_size`: The size of the file in bytes.\n\n**Output:**\n* A dictionary containing the following keys and their corresponding values:\n    * `\"qfile_id\"` : File identifier \n    * `\"qfile_path\"` : File path\n    * `\"original_file_name\"`:  Original filename\n    * `\"file_md4\"` : File MD5 hash\n    * `\"file_size\"` : File size \n\n\n\n"
    },
    "quivr_core__files__file__QuivrFile__open": {
        "label": "open",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 112,
        "endLineNo": 119,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L112-L119&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:**  This asynchronous function opens a file specified by `self.path` in binary read mode (`\"rb\"`). It yields the opened file object, allowing for processing in chunks, and ensures the file is closed properly using a `finally` block. The purpose seems to be efficient and safe file handling for asynchronous tasks. \n\n**Inputs:**\n\n*  `self.path`:  The path to the file to be opened.\n\n**Output:**\n\n* An asynchronous file object (`f`) open in binary read mode. \n\n\n"
    },
    "quivr_core__models__Source": {
        "label": "Source",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 40,
        "endLineNo": 47,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L40-L47&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Please provide the function you'd like me to analyze.  I need the code to give you a summary, inputs, and output. \n\n"
    },
    "quivr_core__processor__implementations__default__ProcessorInit": {
        "label": "ProcessorInit",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 33,
        "endLineNo": 40,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L33-L40&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown:\n\n**Quick Summary:**\n\nThis function acts as a constructor (`__init__`) for a class, likely related to processing data. It takes arbitrary arguments (`*args`) and keyword arguments (`**loader_kwargs`), but doesn't currently do anything with them. The comment suggests the class might dynamically create sub-classes, raising concerns about code clarity and LSP completion due to the opaque nature of these sub-classes.\n\n\n**Inputs:**\n\n* `*args`: A variable number of positional arguments. Their meaning is unknown within the provided context.\n* `**loader_kwargs`: A dictionary of keyword arguments. Their meaning is also unknown within the provided context. \n\n**Output:**\n\n* None : The function doesn't explicitly return any value. \n"
    },
    "quivr_core__storage__file__QuivrFile__metadata": {
        "label": "metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 104,
        "endLineNo": 111,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L104-L111&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the code snippet:\n\n**[Quick Summary]**\n\nThis Python function likely represents a method within a class designed to handle files. It constructs a dictionary containing key information about a specific file (likely stored within the class instance), including its unique identifier, location, original name, MD5 hash, and size.  The purpose is to provide a structured representation of file details for retrieval or transmission.\n\n**[Inputs]**\n\n*  It likely takes no explicit inputs, as it relies on attributes already stored within the object it's called upon (e.g., `self.id`, `self.path`, etc.).\n\n**[Output]**\n\n*  A dictionary with the following keys and values:\n    * `\"qfile_id\"`:  The file's unique identifier (e.g., an ID assigned to it internally).\n    * `\"qfile_path\"`:  The file's path on the system.\n    * `\"original_file_name\"`: The file's name as originally uploaded or accessed.\n    * `\"file_md4\"`:  The file's MD5 hash (a unique cryptographic checksum).\n    * `\"file_size\"`: The file's size in bytes. \n\n\nLet me know if you'd like a deeper dive into any specific aspect of the code!\n"
    },
    "quivr_core__storage__file__QuivrFile__open": {
        "label": "open",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 95,
        "endLineNo": 102,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L95-L102&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis asynchronous function opens a file in read-binary mode (`rb`), yields a file object that can be used to read the file content, and ensures the file is closed after the operation, regardless of success or error. \n\nThe code likely aims to provide a generator-based interface for reading files asynchronously, allowing efficient processing of large files in chunks.\n\n## Inputs\n\n* `self.path`: The path to the file to be opened.\n\n## Output\n\n*  A file object (`aiofiles.File`) opened in read-binary mode (`rb`), yielding the file content for further processing.\n\n\n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase____init_subclass__": {
        "label": "__init_subclass__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 11,
        "endLineNo": 18,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L11-L18&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function customizes the `__init_subclass__` method of an abstract class, ensuring that certain required attributes (like \"name\") are defined before instantiation.  It enforces constraints on subclasses, preventing incomplete or improper initialization. \n\n## Inputs\n\n\n*  `cls`: The abstract class itself.\n* `required`: A tuple containing attribute names that must be defined by subclasses.\n* `kwargs`: Keyword arguments passed to the `__init_subclass__` method.\n\n## Output\n\n* A subclass of the abstract class, with a TypeError raised if required attributes are not defined. \n"
    },
    "tests__processor__test_registr__test_get_default_processors_cls_core": {
        "label": "test_get_default_processors_cls_core",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 38,
        "endLineNo": 45,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L38-L45&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Python Code Analysis\n\n**Quick Summary:**\n\nThis Python code snippet defines a function `get_processor_class` that dynamically determines the appropriate text processing class based on a given file extension. It then tests this functionality by asserting that the correct processor class is returned for  `.txt` (SimpleTxtProcessor) and  `.pdf` (TikaProcessor). The purpose is to demonstrate a flexible system for handling different file types.\n\n**Inputs:**\n\n* `FileExtension`: An enum or class representing a file type extension (e.g., .txt, .pdf).\n\n**Output:**\n\n* A class instance: \n    * The returned class represents the appropriate text processor for the given file type. \n\n\n"
    },
    "tests__processor__test_registr__test_get_processor_cls_import_error": {
        "label": "test_get_processor_cls_import_error",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 138,
        "endLineNo": 145,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L138-L145&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]** \n\nThis code snippet aims to test the resilience of a function called `get_processor_class` against missing HTML parsing capabilities. It anticipates an `ImportError` if the function tries to process a \".html\" file without the necessary HTML parsing libraries available.\n\n**[Inputs]**\n\n*  `.html`:  This likely refers to a file extension, indicating that the function is designed to process HTML files.\n\n**[Output]**\n\n* `ImportError`: The expected outcome is an `ImportError` being raised, signifying that the required HTML parsing library is missing. \n\n\n\n"
    },
    "tests__processor__test_registr__test_register_non_processor": {
        "label": "test_register_non_processor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 184,
        "endLineNo": 191,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L184-L191&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\nThis code snippet tests the registration of a processor for a specific file type. It aims to verify that the registration process correctly throws an `AssertionError` when attempting to register a processor that does not support the given file extension.\n\n## Inputs\n*  `.pdf`:  This likely represents the file extension being registered for processing.\n*  `NOTPROC`:  This appears to be a class intended to represent a processor.\n\n## Output\n*  `AssertionError`:  This exception is expected to be raised during the registration process due to a mismatch between the file extension and the processor's supported extensions. \n\n\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 15,
        "endLineNo": 21,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L15-L21&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down this code snippet.\n\n**[Quick Summary]**\n\nThis function likely initializes a class or object designed to interact with a large language model (LLM). It sets up configuration parameters (`self._config`), loads the actual LLM (`self._llm`), and determines if the model has the capability to understand and execute function calls (`self._supports_func_calling`).\n\n**[Inputs]**\n\n-  `llm_config`:  Likely a dictionary or object containing settings specific to the LLM being used (e.g., model name, temperature, etc.).\n-  `llm`: The instantiated large language model object itself.  \n  \n\n**[Output]**\n\n-  A prepared instance of the class, ready to interact with the specified LLM.\n-  Internal state variables are set (`self._config`, `self._llm`, `self._supports_func_calling`) enabling the class to function.  \n\n\n\nLet me know if you have any more code snippets you'd like me to analyze!\n"
    },
    "quivr_core__models__RAGResponseMetadata": {
        "label": "RAGResponseMetadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 67,
        "endLineNo": 73,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L67-L73&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down this code snippet.\n\n**Quick Summary**\n\nThis code defines the structure for an object likely representing a historical chat interaction within a large language model (LLM) system. It stores information about citations, follow-up questions, sources, and metadata related to the conversation.\n\n**Inputs**\n\n*  `citations:`  A list of integers, possibly representing IDs or indices of cited sources.\n* `followup_questions:` A list of strings, outlining questions raised in continuation of the chat.\n* `sources:` A potentially heterogeneous list containing various data types representing the sources used or referenced during the interaction.\n* `metadata_model:` An instance of a class named `ChatLLMMetadata`, likely holding additional structured information about the chat context.\n\n**Output**\n\nThe code itself doesn't produce an immediate output.  It defines a blueprint for an object that can hold information about a past chat interaction within a system. \n\n\n\nLet me know if you'd like me to elaborate on any of these points!\n"
    },
    "quivr_core__processor__implementations__default__ProcessorInit____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 34,
        "endLineNo": 40,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L34-L40&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Please provide the code selection you would like me to analyze. \n\n"
    },
    "quivr_core__processor__implementations__tika_processor__TikaProcessor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/tika_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/tika_processor.py",
        "lineNo": 60,
        "endLineNo": 66,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Ftika_processor.py%23L60-L66&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary \n\nThis function processes a file, extracts its text content using Tika, and splits the text into individual documents using a text splitter.  The purpose is to analyze and organize text from a file into manageable chunks. \n\n## Inputs\n\n*  **file:**  This is likely a file-like object representing the input file containing text.\n*  **self._send_parse_tika:** This appears to be a method within the same class, responsible for sending the file content to a Tika service for parsing and returning the extracted text.\n*  **self.text_splitter:**  This is another object (likely a class instance) responsible for splitting the extracted text into documents based on defined criteria.\n\n## Output\n\n*  **docs:** A list of Document objects, each representing a single, extracted document from the input file.  \n"
    },
    "tests__conftest__temp_data_file": {
        "label": "temp_data_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 19,
        "endLineNo": 25,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L19-L25&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function creates a temporary text file, writes sample data into it, and returns the file path. Its purpose is likely to provide a temporary data file for testing or development purposes.\n\n## Inputs\n\n*  `data`:  A string containing the text data to be written to the file.\n*  `tmp_path`:  A path object representing the directory where the temporary file will be created.\n\n## Output\n\n* `temp_file`: A file path (string) pointing to the newly created temporary file. \n\n\n\n"
    },
    "tests__processor__test_tika_processor__test_process_file": {
        "label": "test_process_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_tika_processor.py",
        "relativePath": "backend/core/tests/processor/test_tika_processor.py",
        "lineNo": 10,
        "endLineNo": 16,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_tika_processor.py%23L10-L16&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**Quick summary**\n\nThis code snippet processes a PDF file (`quivr_pdf`) using the Tika library, extracts text content from the first page, and asserts that the extracted text matches \"Dummy PDF download.\" It likely aims to verify the successful extraction of text from a specific PDF file.\n\n**Inputs:**\n\n* `quivr_pdf`: A file object or path representing a PDF file.\n\n* `TikaProcessor()`: An instance of a class (presumably defined elsewhere) that utilizes the Tika library to process PDF files.\n\n**Output:**\n\n* `doc`: An object containing processed text content from the PDF file (potentially a list of pages).\n*  `doc[0].page_content`: Text content from the first page of the PDF.\n* Assertions: Pass if the extracted text from the first page is \"Dummy PDF download,\" fail otherwise. \n\n\n\n"
    },
    "tests__processor__test_tika_processor__test_send_parse_tika_exception": {
        "label": "test_send_parse_tika_exception",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_tika_processor.py",
        "relativePath": "backend/core/tests/processor/test_tika_processor.py",
        "lineNo": 19,
        "endLineNo": 25,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_tika_processor.py%23L19-L25&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "```python\n    # TODO: Mock correct tika for retries\n    tparser = TikaProcessor(tika_url=\"test.test\")\n    with pytest.raises(RuntimeError):\n        doc = await tparser.process_file(quivr_pdf)\n        assert len(doc) > 0\n        assert doc[0].page_content.strip(\"\\n\") == \"Dummy PDF download\"\n```\n\n\n\n[Quick summary]\nThis code snippet appears to be a test case designed to verify the error handling of a  `TikaProcessor` object. It expects the processor to raise a `RuntimeError` when processing a PDF file (`quivr_pdf`) and then asserts that specific conditions would be violated if the error handling wasn't correctly implemented. \n\n[Inputs]\n*  `tika_url`:  Likely a URL pointing to a Tika instance (mocked in this case)\n* `quivr_pdf`:  A PDF file object. \n\n[Output]\n* A `RuntimeError` should be raised. \n"
    },
    "tests__test_llm_endpoint__test_llm_endpoint_constructor": {
        "label": "test_llm_endpoint_constructor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_llm_endpoint.py",
        "relativePath": "backend/core/tests/test_llm_endpoint.py",
        "lineNo": 43,
        "endLineNo": 49,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_llm_endpoint.py%23L43-L49&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Okay, let's break down this code snippet.\n\n**[Quick Summary]**   \n\nThis code creates a simulated LLM (Large Language Model) endpoint and configures it to not support function calling. It then asserts that the endpoint, as expected, does not support function calls. This is likely a test setup to verify behavior in a scenario where function calling is not implemented.\n\n**[Inputs]**\n\n* `FakeListChatModel(responses=[])`: This appears to be a placeholder or mock implementation of an LLM, providing a list of predefined responses.\n* `LLMEndpointConfig(model=\"test\")`: This configures the `LLMEndpoint`, potentially specifying the type or version of the LLM (\"test\" in this case). \n\n**[Output]**\n\n* `assert not llm_endpoint.supports_func_calling()`:  The assertion will pass, confirming that the `llm_endpoint` does not support function calling. This implies the test is successful. \n\n\nLet me know if you have any more code snippets you'd like analyzed!\n"
    },
    "quivr_core__brain__brain__Brain__print_info": {
        "label": "print_info",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 86,
        "endLineNo": 91,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L86-L91&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown\n\n**Quick summary:** This code snippet generates a visual representation (a tree-like structure) of information about a 'self' object (presumably some kind of data structure) and displays it within a panel titled \"Brain Info\". The 'console' object likely handles the output display.\n\n**Inputs:**\n\n*  `self`:  The object containing information to be visualized.\n*  `Console()`: An object responsible for displaying output. \n\n**Output:**\n\n* A panel titled \"Brain Info\" containing a tree-like visualization of the 'self' object's data. \n\n\n"
    },
    "quivr_core__chat__ChatHistory____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 10,
        "endLineNo": 15,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L10-L15&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]** This code snippet defines a class, likely representing a conversation or chat session. It initializes attributes for a unique `chat_id` and a `brain_id`, possibly linking it to a specific AI model. It also creates a list `_msgs` to store chat messages.  \n\n\n**[Inputs]**\n\n* `chat_id`: A unique identifier for the chat session.\n* `brain_id`:  An identifier for the AI model or brain associated with this chat.\n\n**[Output]** \n*  An instance of the class representing a chat session, ready to store and manage messages.  \n\n\n\n\n Let me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "quivr_core__models__ParsedRAGChunkResponse": {
        "label": "ParsedRAGChunkResponse",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 79,
        "endLineNo": 84,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L79-L84&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function appears to be designed as part of a question-answering system powered by a Retrieval Augmented Generation (RAG) model. It processes a user query and returns a textual answer along with metadata about the response and a flag indicating if it's the last part of a multi-part answer. \n\n**Inputs:**\n- `query`: The user's question or prompt. \n- `context`:  Likely additional information relevant to the query, potentially a document or passage.\n\n**Output:**\n- `answer`: A string containing the generated answer to the query.\n- `metadata`: Information about the response, possibly including source documents or reasoning steps.\n- `last_chunk`: A boolean value indicating if this is the final part of a multi-part response.  \n\n\n"
    },
    "quivr_core__processor__implementations__default___build_processor___Processor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/default.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/default.py",
        "lineNo": 71,
        "endLineNo": 76,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fdefault.py%23L71-L76&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Summary \n\nThis function generates a configuration dictionary for a processing pipeline, likely used for training or evaluating a machine learning model. It specifies the type of processor class and the configuration for the data splitter.\n\n## Inputs\n\n* **self.loader_cls:**  Represents the class responsible for loading data.\n* **self.splitter_config:** An object containing settings for how to split the data (e.g., train/test split ratio, shuffle).\n\n## Output\n\n* **\"processor_cls\":** A string containing the name of the data loader class.\n* **\"splitter\":** A dictionary representing the data splitter configuration. \n\n\n"
    },
    "quivr_core__processor__implementations__simple_txt_processor__SimpleTxtProcessor____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "lineNo": 32,
        "endLineNo": 37,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fsimple_txt_processor.py%23L32-L37&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Snippet Analysis\n\n**Quick Summary:** This Python function initializes a new object, likely a class related to data splitting. It inherits from a parent class (`super().__init__(**kwargs)`) and stores a configuration object (`splitter_config`) specific to the splitting process. The purpose of this code is to set up an object that will handle the splitting of data based on provided configuration.\n\n**Inputs:**\n\n* `splitter_config: SplitterConfig = SplitterConfig()`: An object of type `SplitterConfig`, which presumably holds parameters controlling how the data will be split. \n* `**kwargs`:  Keyword arguments that can be passed to the parent class's constructor (`__init__`), possibly for additional object-level initialization.\n\n**Output:**\n\n*  A newly created object of the current class, initialized with the given `splitter_config` and any keyword arguments.  \n"
    },
    "quivr_core__processor__implementations__simple_txt_processor__SimpleTxtProcessor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/simple_txt_processor.py",
        "lineNo": 39,
        "endLineNo": 44,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fsimple_txt_processor.py%23L39-L44&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:** This function defines a processor configuration for a text processing pipeline, specifying the processor class (`SimpleTxtProcessor`) and a data splitter based on the `splitter_config` object. This configuration is likely intended for use with a machine learning model that requires text data to be preprocessed. \n\n**Inputs:**\n\n* `self.splitter_config`: This likely refers to an object containing settings for splitting text data, such as splitting by sentences or paragraphs.\n\n**Output:**\n\n* A dictionary containing:\n    * `\"processor_cls\"`: A string specifying the class name of the text processor used. In this case, it's \"SimpleTxtProcessor\".\n    * `\"splitter\"`: The output of the `model_dump()` method on the `splitter_config` object. This method likely serializes the splitter configuration into a format suitable for use by other components. \n\n\n\n"
    },
    "quivr_core__processor__registr__ProcEntry": {
        "label": "ProcEntry",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 23,
        "endLineNo": 28,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L23-L28&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis code snippet defines fields for a data structure likely used to represent an item in a prioritized task list or queue. The `priority` field dictates the order of execution, `cls_mod` probably stores information about the class or module associated with the item, and `err` holds any error messages related to the item.\n\n## Inputs\n\n* `priority`:  An integer representing the importance or urgency of the task.\n\n* `cls_mod`: A string describing the class or module associated with the task.\n\n* `err`:  A string containing an error message (optional), or `None` if no error exists.\n\n## Output\n\n* A structured data object representing a task item with its priority, class/module affiliation, and potential error information. \n"
    },
    "quivr_core__storage__file__FileExtension": {
        "label": "FileExtension",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/file.py",
        "relativePath": "backend/core/quivr_core/storage/file.py",
        "lineNo": 14,
        "endLineNo": 19,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Ffile.py%23L14-L19&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**Quick Summary**\n\nThis code snippet defines variables representing common file extensions: \".txt\" for text files, \".pdf\" for Portable Document Format files, and \".docx\" for Microsoft Word documents.  It likely serves as a starting point for a larger program that needs to handle different file types. \n\n**Inputs**\n\n* There are no explicit inputs to this code. \n\n**Output**\n\n* There is no explicit output from this code. \n\n\n\n"
    },
    "tests__processor__test_registr__test_known_processors": {
        "label": "test_known_processors",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 118,
        "endLineNo": 123,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L118-L123&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**Quick Summary:**  This code snippet checks if every file extension defined in the `FileExtension` enumeration has a corresponding default processor listed in `known_processors`. If any extension lacks a processor, it raises an error. The purpose is to ensure that all supported file types have handling mechanisms within the system.\n\n**Inputs:**\n\n* `known_processors`: A set or list of string representing known file processors.\n* `FileExtension`: An enumeration defining various file extensions.\n\n**Output:**\n\n* Raises an error \"base-env: Some file extensions don't have a default processor\" if any extension from `FileExtension`  is not found in `known_processors`. \n* No explicit return value, the function mainly performs an assertion. \n\n\n"
    },
    "tests__processor__test_registr__test_register_new_proc__TestProcessor": {
        "label": "TestProcessor",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 171,
        "endLineNo": 176,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L171-L176&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick summary]\n\nThis function, `process_file`,  is designed to handle files with the \".test\" extension.  It is intended to read a  QuivrFile object and return a list of Document objects, likely representing processed content extracted from the file. \n\n[Inputs]\n* `self`:  This refers to the instance of the class containing this function. \n* `file: QuivrFile`: An object representing a file, likely specific to a system or library named \"Quivr\".\n\n[Output]\n* `list[Document]`: A list containing Document objects. These likely represent extracted or processed information from the input QuivrFile.  \n\n\n\n"
    },
    "tests__test_config__test_default_ragconfig": {
        "label": "test_default_ragconfig",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_config.py",
        "relativePath": "backend/core/tests/test_config.py",
        "lineNo": 21,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_config.py%23L21-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "You haven't provided any code for me to analyze. Please provide the code snippet you'd like me to examine.  \n\n"
    },
    "quivr_core__brain__brain__Brain___init_chats": {
        "label": "_init_chats",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 113,
        "endLineNo": 117,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L113-L117&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**[Quick Summary]**\n\nThis function creates a new chat history entry for a brain instance. It generates a unique identifier (chat_id) for the chat and associates it with the brain's ID, storing the information in a `ChatHistory` object. This likely purports to initialize a new conversation thread.\n\n**[Inputs]**\n\n*  `self.id`:  The unique identifier of the brain instance.\n\n**[Output]**\n\n*  A dictionary: \n    *  key:  The generated `chat_id`\n    *  value: A `ChatHistory` object representing the new chat entry. \n\n\n\n\n\n"
    },
    "quivr_core__brain__brain__Brain__add_file": {
        "label": "add_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 245,
        "endLineNo": 249,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L245-L249&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "The code you provided is incomplete and indicates the intention to write a function that handles some kind of data storage.  It's designed to take input, potentially process it, and store it in two places: a general storage location and a specialized \"vectorstore.\"\n\n**[Inputs]**\n\n* The specific input(s) are missing from the code snippet.\n\n\n**[Output]**\n\n* The code would ideally provide a confirmation that the data has been stored successfully in both locations.  \n\n"
    },
    "quivr_core__brain__info__StorageInfo__add_to_tree": {
        "label": "add_to_tree",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/info.py",
        "relativePath": "backend/core/quivr_core/brain/info.py",
        "lineNo": 48,
        "endLineNo": 52,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Finfo.py%23L48-L52&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**Quick Summary:**\n\nThis code snippet appears to be part of a function that generates a textual representation of some storage information.  It formats and adds details about the \"Storage Type\" and \"Number of Files\" to a data structure called `files_tree`.  The purpose might be to create a report or display information about a storage system. \n\n**Inputs:**\n\n*  `self.storage_type`:  A string representing the type of storage (e.g., \"HDD\", \"SSD\", \"Cloud\").\n*  `self.n_files`: An integer representing the number of files stored.\n*  `files_tree`:  A data structure likely capable of holding hierarchical text elements, possibly a tree or list-like structure.\n\n**Output:**\n\n\n* A modified `files_tree` containing two new elements: \n    *  The \"Storage Type\" formatted in italics.\n    *  The \"Number of Files\" formatted in bold. \n\n"
    },
    "quivr_core__config__RAGConfig": {
        "label": "RAGConfig",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/config.py",
        "relativePath": "backend/core/quivr_core/config.py",
        "lineNo": 14,
        "endLineNo": 18,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fconfig.py%23L14-L18&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:**\n\nThis code snippet likely initializes parameters for an interaction with a large language model (LLM). It sets up configuration for the LLM endpoint, defines the maximum conversation history and number of files to be used, and specifies an optional prompt. The purpose seems to be to prepare for a controlled interaction with the LLM, tailoring its behavior and input.\n\n**Inputs:**\n\n* `llm_config`: An object representing the configuration for the LLM endpoint (e.g., API key, address, model version).\n* `max_history`: An integer specifying the maximum number of previous messages to be considered during the LLM's response.\n* `max_files`: An integer indicating the maximum number of files that can be referenced or uploaded during the interaction.\n* `prompt`: An optional string containing the initial message or instruction for the LLM.\n\n**Output:**\n\n* None: This code likely sets up parameters without directly producing a result. \n\n\n"
    },
    "quivr_core__models__ParsedRAGResponse": {
        "label": "ParsedRAGResponse",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 74,
        "endLineNo": 78,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L74-L78&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**[Quick summary]**\n\nThis Python function likely defines an interface for a response generated by a Retrieval Augmented Generation (RAG) model. It prepares a structured response containing both textual content (`answer`) and metadata (`RAGResponseMetadata`) about the response. The purpose is to provide a consistent format for handling responses from RAG systems.\n\n**[Inputs]**\n\n\n* `answer`: A string representing the textual content of the response generated by the RAG model.\n\n**[Output]**\n\n\n* `answer`: A string containing the generated text.\n* `metadata`: An object of type `RAGResponseMetadata` which likely holds information about the source of the answer, its confidence, and other relevant details. \n"
    },
    "quivr_core__models__RawRAGChunkResponse": {
        "label": "RawRAGChunkResponse",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 48,
        "endLineNo": 52,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L48-L52&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis function likely processes some kind of data represented as dictionaries.  It takes two dictionaries as input: one likely containing parameters or settings, and the other containing raw data. The function then likely manipulates or analyzes this data based on the parameters and returns a modified dictionary.\n\n\n## Inputs\n\n*  `answer`: A dictionary likely containing the processed or analyzed data.\n* `docs`: A dictionary potentially containing the input data to be processed.\n\n## Output\n\n* A dictionary (`answer`) containing the processed or analyzed data. \n"
    },
    "quivr_core__models__RawRAGResponse": {
        "label": "RawRAGResponse",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 53,
        "endLineNo": 57,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L53-L57&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Summary:\n\nThis code likely defines a function that processes some data (possibly retrieved from a source) and returns two values: a dictionary called `answer` and another dictionary called `docs`. The purpose of the code is likely related to information retrieval, analysis, or structuring based on the input data. \n\n## Inputs:\n\n*  **This code snippet only defines the expected return types, it does not show the inputs to the function.**  To determine the inputs, we would need to see the function definition.\n\n## Output:\n\n*  `answer`: a dictionary where keys are strings and values can be of any type (`Any`)\n*  `docs`: a dictionary where keys are strings and values can be of any type (`Any`) \n"
    },
    "quivr_core__processor__implementations__megaparse_processor__MegaparseProcessor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/megaparse_processor.py",
        "lineNo": 43,
        "endLineNo": 47,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Fmegaparse_processor.py%23L43-L47&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**Quick Summary**\nThis function returns the `chunk_overlap` value from a `splitter_config` object. The purpose is likely to retrieve a configuration parameter related to how chunks are handled, likely for splitting a larger dataset or file.\n\n**Inputs**\n\n* **self**: Refers to the instance of the class containing this method.\n\n* **splitter_config**: An object presumably holding configuration parameters for a splitting process.\n\n\n**Output**\n\n* A dictionary containing a single key-value pair:\n    * `\"chunk_overlap\"`: The value representing the overlap between adjacent chunks. \n"
    },
    "quivr_core__processor__implementations__tika_processor__TikaProcessor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/implementations/tika_processor.py",
        "relativePath": "backend/core/quivr_core/processor/implementations/tika_processor.py",
        "lineNo": 55,
        "endLineNo": 59,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fimplementations%2Ftika_processor.py%23L55-L59&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Breakdown\n\n**Quick Summary:**\n\nThis function returns the `chunk_overlap` value from a configuration object (`self.splitter_config`). It likely belongs to a class responsible for splitting data into chunks, with  `chunk_overlap`  determining how much each chunk overlaps with its neighbors. \n\n**Inputs:**\n\n\n* `self.splitter_config`:  A configuration object containing settings for data splitting.\n\n**Output:**\n\n* A dictionary with a single key-value pair:\n    * `\"chunk_overlap\"`:  An integer or float value representing the overlap between consecutive chunks.\n\n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase__info": {
        "label": "info",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 38,
        "endLineNo": 42,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L38-L42&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function likely belongs to a class representing some kind of storage system (e.g., a filesystem, cloud storage). It returns information about the storage, specifically the type of storage and the number of files it contains.  The purpose is to provide a simple way to query basic storage details.\n\n## Inputs\n\n* `self`:  A reference to the current instance of the storage system class.\n\n## Output\n\n* `StorageInfo` object containing:\n    * `storage_type`:  A string representing the type of storage (e.g., \"local\", \"cloud\").\n    * `n_files`: An integer representing the number of files in the storage. \n\n\n"
    },
    "tests__conftest__fake_llm": {
        "label": "fake_llm",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 80,
        "endLineNo": 84,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L80-L84&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the code snippet:\n\n**Quick Summary**\n\nThis function creates a simulated chatbot endpoint. It takes a list of predefined answers (`answers`) and constructs a fake language model (`llm`) using them.  Then, it packages this fake model within an `LLMEndpoint` object, presenting it as if it were a real, externally hosted language model named \"fake_model\". \n\n**Inputs**\n\n* `answers`: A list of strings, likely representing pre-written responses the chatbot will utilize.\n\n**Output**\n\n*  An `LLMEndpoint` object.  This object likely has methods for interacting with the chatbot (e.g., sending a prompt and receiving a response). \n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze! \n"
    },
    "tests__processor__pdf__test_megaparse_pdf_processor__test_get_default_processors_megaparse": {
        "label": "test_get_default_processors_megaparse",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/pdf/test_megaparse_pdf_processor.py",
        "relativePath": "backend/core/tests/processor/pdf/test_megaparse_pdf_processor.py",
        "lineNo": 13,
        "endLineNo": 17,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fpdf%2Ftest_megaparse_pdf_processor.py%23L13-L17&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**[Quick summary]**  This code snippet retrieves a processor class associated with the PDF file extension. It then asserts that the retrieved class is `MegaparseProcessor`, confirming that the system correctly maps PDF files to the specified processor. The purpose is to ensure the correct processing logic is used for PDF documents. \n\n**[Inputs]**\n* `FileExtension.pdf`: This likely represents an enumeration or object representing the \"pdf\" file extension.\n\n**[Output]**\n* `MegaparseProcessor`: The expected output is the `MegaparseProcessor` class, confirming that it is the designated processor for PDF files. \n* `Assertion Passed`:  A successful assertion means the code execution continues without errors. \n\n\n\nLet me know if you have any more code snippets you'd like me to analyze!\n"
    },
    "tests__processor__test_registr__test_get_processor_cls_error": {
        "label": "test_get_processor_cls_error",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 146,
        "endLineNo": 150,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L146-L150&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis code snippet tests a function called `get_processor_class` which likely aims to retrieve a processor class based on a given string argument.  The `pytest.raises(ValueError)` assertion verifies that the function raises a `ValueError` exception when provided with an invalid input string. \n\n[Inputs]\n* \".sdfkj\":  A string argument representing the processor class identifier.\n\n[Output]\n* A `ValueError` exception should be raised.   \n"
    },
    "tests__processor__test_registr__test_register_new_proc_noappend": {
        "label": "test_register_new_proc_noappend",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 151,
        "endLineNo": 155,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L151-L155&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's the breakdown:\n\n**Quick Summary** \n\nThis code snippet appears to be testing a function called `register_processor`. It aims to verify that the `register_processor` function raises a `ValueError` when attempting to register a processor for the `.txt` file extension with the `append` parameter set to `False`.  \n\n**Inputs**\n\n* `FileExtension.txt`:  Represents a file type, likely an enumeration or class indicating a `.txt` file.\n* `\"test.\"`:  Probably a string representing a specific processor identifier or name.\n* `append=False`: A boolean flag controlling whether the new processor is to be appended to existing ones or replace them.\n\n**Output**\n\n*  Expected `ValueError` exception: This indicates that the function encountered an invalid condition (likely due to the `append=False` setting) and chose to halt with an error rather than proceeding. \n\n\nLet me know if you'd like more in-depth analysis of any part of the code!\n"
    },
    "tests__test_quivr_rag__mock_chain_qa_stream__MockQAChain": {
        "label": "MockQAChain",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_quivr_rag.py",
        "relativePath": "backend/core/tests/test_quivr_rag.py",
        "lineNo": 13,
        "endLineNo": 17,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_quivr_rag.py%23L13-L17&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis asynchronous function, `astream`, iterates over a collection named `chunks_stream_answer` and yields each element individually. This suggests it's designed to stream data in smaller chunks, potentially for efficient processing or transmission.\n\n## Inputs\n\n* `*args`:  Arbitrary positional arguments. Not used in the function. Possibly intended for future expansion or compatibility.\n* `**kwargs`: Arbitrary keyword arguments. Not used in the function. Similar to `*args`.\n\n## Output\n\n*  Yields individual elements from the `chunks_stream_answer` collection.  \n\n\n"
    },
    "tests__test_utils__test_model_supports_function_calling": {
        "label": "test_model_supports_function_calling",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_utils.py",
        "relativePath": "backend/core/tests/test_utils.py",
        "lineNo": 14,
        "endLineNo": 18,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_utils.py%23L14-L18&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis code snippet checks if a given language model supports function calling capabilities. It asserts that GPT-4 supports function calling while claiming that Olalla3 does not.  The purpose is likely to verify the functional  abilities of different language models during development or testing.\n\n[Inputs]\n\n* \"gpt-4\": The name of a language model.\n* \"ollama3\": The name of another language model.\n\n[Output]\n\n* True: Indicating GPT-4 supports function calling.\n* False: Indicating Olalla3 does not support function calling. \n\n\n"
    },
    "quivr_core__brain__brain__Brain____repr__": {
        "label": "__repr__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 82,
        "endLineNo": 85,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L82-L85&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function, likely part of a larger class, takes information from the object (`self.info()`) and formats it into a human-readable string using the `PrettyPrinter` library. This aids in debugging or displaying complex data structures in a clear and organized way.\n\n## Inputs\n\n*   `self`: A reference to the current object.\n\n\n*   `self.info()`: A method call that returns a data structure (likely a dictionary or nested list) containing information about the object.\n\n## Output\n\n*   A formatted string representation of the data returned by `self.info()`.  \n"
    },
    "quivr_core__brain__brain__Brain__get_chat_history": {
        "label": "get_chat_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 241,
        "endLineNo": 244,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L241-L244&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's examine the provided Python code snippet. \n\n**Quick Summary**\nThis function named `get_chat` is designed to retrieve a chat object associated with a specific `chat_id`.  It accesses a dictionary named `_chats` to find the chat data based on the provided `chat_id`. The function likely operates within a larger messaging or communication system.\n\n**Inputs**\n\n* `chat_id`: A unique identifier for a particular chat.\n\n**Output**\n\n* The chat object corresponding to the specified `chat_id`. This object likely contains information about the chat, such as participants, messages, etc. \n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "quivr_core__processor__processor_base__ProcessorBase__check_supported": {
        "label": "check_supported",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/processor_base.py",
        "relativePath": "backend/core/quivr_core/processor/processor_base.py",
        "lineNo": 17,
        "endLineNo": 20,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fprocessor_base.py%23L17-L20&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function is designed to ensure a file has a supported file extension before processing it. It checks if the file's extension is present in a list of `supported_extensions`. If not, it raises a `ValueError` indicating the unsupported file type.\n\n## Inputs\n\n- `file`:  Represents an object containing information about the file, including its extension.\n- `self.supported_extensions`: A list of allowed file extensions that the function can process.\n\n## Output\n\n-  Raises a `ValueError` containing a message stating the unsupported file type if the file extension is not in `self.supported_extensions`.\n-  Implicitly continues processing if the file extension is supported.  \n\n\n\n"
    },
    "quivr_core__storage__local_storage__LocalStorage___load_files": {
        "label": "_load_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 27,
        "endLineNo": 30,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L27-L30&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This Python function is designed to load existing files. \n\nThe `# TODO(@aminediro)` comment suggests this is a placeholder indicating the functionality needs to be implemented.  The purpose is likely to read the contents of specified files and potentially use them in the program's logic.\n\n**Inputs:**\n\n*  Unclear from the provided snippet.\n*  Possibly file paths or names as strings.\n\n**Output:**\n\n*  Unclear from the provided snippet.\n*  Possibly file contents as strings or other data structures. \n\n\n\n"
    },
    "quivr_core__storage__local_storage__LocalStorage__remove_file": {
        "label": "remove_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 57,
        "endLineNo": 60,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L57-L60&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Please provide the function selection you would like me to analyze.  \n"
    },
    "quivr_core__utils__cited_answer_filter": {
        "label": "cited_answer_filter",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/utils.py",
        "relativePath": "backend/core/quivr_core/utils.py",
        "lineNo": 54,
        "endLineNo": 57,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Futils.py%23L54-L57&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis function checks if a tool has the name \"cited_answer\". It's likely part of a system that manages or categorizes different tools based on their functionality.\n\n## Inputs\n\n*  `tool`: This is likely a dictionary or object representing a tool with various properties, including a \"name\" attribute.\n\n## Output\n\n*  `True`: If the tool's name is \"cited_answer\".\n*  `False`: If the tool's name is not \"cited_answer\". \n\n\n"
    },
    "tests__conftest__answers": {
        "label": "answers",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 75,
        "endLineNo": 78,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L75-L78&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function generates a list of 10 strings, each named \"answer_\" followed by a number from 0 to 9. This suggests a mechanism for creating distinct identifiers or labels for responses, likely within a question-answering system or similar scenario.\n\n## Inputs\n\n* `None`: This function does not explicitly take any inputs.\n\n## Output\n\n* A list containing 10 strings: \n    * \"answer_0\"\n    * \"answer_1\"\n    * \"answer_2\"\n    * \"answer_3\"\n    * \"answer_4\"\n    * \"answer_5\"\n    * \"answer_6\"\n    * \"answer_7\"\n    * \"answer_8\"\n    * \"answer_9\" \n\n\n\n\n"
    },
    "tests__conftest__embedder": {
        "label": "embedder",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 86,
        "endLineNo": 89,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L86-L89&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\n\nThis function creates and returns an instance of a `DeterministicFakeEmbedding`, which is likely a placeholder or simulated embedding model used for testing or demonstration purposes.  Deterministic means the output will always be the same for the same input, making it predictable. The `size=20` parameter specifies that the embedding will have a dimensionality of 20.\n\n[Inputs]\n* `size`: An integer representing the desired dimensionality of the embedding (20 in this case).\n\n[Output]\n* An instance of the `DeterministicFakeEmbedding` class with the specified size. \n"
    },
    "tests__conftest__full_response": {
        "label": "full_response",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 51,
        "endLineNo": 54,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L51-L54&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**Quick Summary:** This code defines a function that provides a concise explanation of Natural Language Processing (NLP). Its purpose is to educate or inform users about the fundamentals of NLP.\n\n**Inputs:** None, it's a function without explicit inputs.\n\n**Output:**  \n* A string describing Natural Language Processing (NLP). \n"
    },
    "tests__conftest__openai_api_key": {
        "label": "openai_api_key",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 70,
        "endLineNo": 73,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L70-L73&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown:\n\n**Quick Summary:** This code sets an environment variable named \"OPENAI_API_KEY\" to the value \"abcd\". This is likely intended to configure an application to use an OpenAI API, where \"abcd\" represents a placeholder for an actual API key. \n\n**Inputs:**\n\n* \"OPENAI_API_KEY\":  An environment variable name.\n* \"abcd\": The value to be assigned to the environment variable. This *should* be replaced with an actual OpenAI API key.\n\n **Output:**\n\n*  The environment variable \"OPENAI_API_KEY\" will now hold the value \"abcd\". \n\nLet me know if you'd like a more in-depth explanation of environment variables or the OpenAI API! \n"
    },
    "tests__processor__docx__test_docx__test_docx_processor_fail": {
        "label": "test_docx_processor_fail",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/docx/test_docx.py",
        "relativePath": "backend/core/tests/processor/docx/test_docx.py",
        "lineNo": 29,
        "endLineNo": 32,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fdocx%2Ftest_docx.py%23L29-L32&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**[Quick summary]** \n\nThis code snippet tests a function called `process_file()` from a class called `DOCXProcessor`. It's designed to check if the function raises a `ValueError` when given a file that isn't in the expected format (likely a .docx file).  \n\n**[Inputs]**\n\n*   `processor`: An instance of the `DOCXProcessor` class.\n*   `quivr_txt`: This is likely a string representing the path to a file, but the code indicates it's not a .docx file.\n\n**[Output]**\n\n*   Raises a `ValueError`  because the input file is not a .docx file. \n\n\n"
    },
    "tests__processor__epub__test_epub_processor__test_epub_processor_fail": {
        "label": "test_epub_processor_fail",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/epub/test_epub_processor.py",
        "relativePath": "backend/core/tests/processor/epub/test_epub_processor.py",
        "lineNo": 47,
        "endLineNo": 50,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Fepub%2Ftest_epub_processor.py%23L47-L50&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**\n\nThis code snippet tests a function called `process_file` within a class named `EpubProcessor`. It's designed to check if the function raises a `ValueError` when given a specific input, likely an improperly formatted EPUB file or data represented by the variable `quivr_txt`. The purpose is to ensure the function handles invalid input gracefully and throws an error.\n\n**[Inputs]**\n\n*  `processor`: An instance of the `EpubProcessor` class.\n*  `quivr_txt`: This variable likely holds the content of an EPUB file or related data in a text format, possibly intended for processing by the `EpubProcessor`. \n\n**[Output]**\n\n*  A `ValueError` exception is expected to be raised.  \n\n\n\nLet me know if you'd like a deeper dive into any specific aspect!"
    },
    "tests__test_chat_histor__ai_message": {
        "label": "ai_message",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 11,
        "endLineNo": 14,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L11-L14&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:**\n\nThis function defines a simple Python function named `return AIMessage(\"ai message\")` that creates and returns an instance of a class or object named `AIMessage`. The purpose of this code is to likely create a message object representing a response from an Artificial Intelligence. \n\n**Inputs:**\n\n* `\"ai message\"`: This string is the content of the AI message.\n\n**Output:**\n\n* An `AIMessage` object containing the text \"ai message\".  \n\n\nLet me know if you'd like me to elaborate on any of these points!\n"
    },
    "tests__test_chat_histor__human_message": {
        "label": "human_message",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_chat_history.py",
        "relativePath": "backend/core/tests/test_chat_history.py",
        "lineNo": 16,
        "endLineNo": 19,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_chat_history.py%23L16-L19&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis:\n\n**[Quick Summary]**  This function defines a method (likely within a class) called `return HumanMessage` that takes a string argument and constructs a `HumanMessage` object containing that string. The purpose of the function is to encapsulate and format human-readable text for potential display or processing.\n\n**[Inputs]**\n\n*  `\"human message\"`: This is a string representing the textual content intended for human consumption.\n\n**[Output]**\n\n* A `HumanMessage` object containing the string `\"human message\"`. \n\n\nLet me know if you'd like me to elaborate on any of these points or explore potential use cases for a `HumanMessage` object. \n"
    },
    "tests__test_quivr_rag__mock_chain_qa_stream__MockQAChain__astream": {
        "label": "astream",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_quivr_rag.py",
        "relativePath": "backend/core/tests/test_quivr_rag.py",
        "lineNo": 14,
        "endLineNo": 17,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_quivr_rag.py%23L14-L17&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown\n\n**Quick Summary:** This function iterates through a stream of data (`chunks_stream_answer`) and yields each chunk individually. This suggests it's designed to process large datasets efficiently, breaking them down into manageable pieces. \n\n**Inputs:**\n\n* `chunks_stream_answer`: A stream of data, likely generated from some external source. \n\n**Output:**\n\n*  Successive chunks of data from `chunks_stream_answer`, yielded one at a time. \n\n\n"
    },
    "quivr_core__brain__brain__Brain__chat_history": {
        "label": "chat_history",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/brain/brain.py",
        "relativePath": "backend/core/quivr_core/brain/brain.py",
        "lineNo": 110,
        "endLineNo": 112,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fbrain%2Fbrain.py%23L110-L112&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function  presumably defined within a class, returns a predefined value called `default_chat`. The purpose appears to be to provide a fallback or initial chat response when no other specific response is available.\n\n## Inputs\n\n*  None explicitly listed.  It might rely on internal state or context within the class.\n\n## Output\n\n* `self.default_chat`: This is likely a string or data structure containing the default chat response. \n\n\n"
    },
    "quivr_core__chat__ChatHistory____len__": {
        "label": "__len__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat.py",
        "relativePath": "backend/core/quivr_core/chat.py",
        "lineNo": 27,
        "endLineNo": 29,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat.py%23L27-L29&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Function Breakdown \n\n**[Quick Summary]** This function, likely part of a class, calculates and returns the number of messages stored within an internal list called `_msgs`.  The purpose is to provide an easy way to determine the size of the message collection.\n\n**[Inputs]**\n\n*  `self`:  A reference to the current instance of the class.\n\n**[Output]**\n\n* An integer representing the number of messages in the `_msgs` list. \n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!"
    },
    "quivr_core__chat_llm__ChatLLM____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/chat_llm.py",
        "relativePath": "backend/core/quivr_core/chat_llm.py",
        "lineNo": 24,
        "endLineNo": 26,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fchat_llm.py%23L24-L26&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Okay, here's a breakdown of the code snippet you provided:\n\n**[Quick summary]**\n\nThis code snippet is setting up a variable called `self.llm_endpoint` to store the address (or some identifier) of a Large Language Model (LLM). The purpose is likely to allow the programmer to interact with this LLM later in the code.\n\n**[Inputs]**\n\n* `llm`: This is likely a string value representing the URL, API key, or some other identifier for the LLM endpoint.\n\n**[Output]**\n\n* `self.llm_endpoint`: A variable that now holds the information for accessing the specified LLM. \n\n\n\nLet me know if you'd like me to elaborate on any part! \n"
    },
    "quivr_core__files__file__QuivrFile____repr__": {
        "label": "__repr__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/files/file.py",
        "relativePath": "backend/core/quivr_core/files/file.py",
        "lineNo": 108,
        "endLineNo": 110,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Ffiles%2Ffile.py%23L108-L110&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function constructs a string representation of a file object, likely within a file-management system or platform. It includes the identifier (\"QuivrFile-\") followed by the file's unique ID and its original filename. The purpose appears to be creating a descriptive label for the file. \n\n## Inputs\n\n* `self.id`:  A unique identifier for the file object.\n\n* `self.original_filename`: The name of the file before any potential modifications or renaming.\n\n## Output\n\n* A formatted string: \"QuivrFile-{self.id} original_filename:{self.original_filename}\"\n\n\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint__get_config": {
        "label": "get_config",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 22,
        "endLineNo": 24,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L22-L24&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the provided code snippet:\n\n**[Quick Summary]**\n\nThis function likely retrieves and returns a configuration object (`self._config`) that stores settings or parameters for an object. The purpose is to provide access to these configuration values within the class. \n\n**[Inputs]**\n\n* **`self`:**  A reference to the current instance of the class. This allows the function to access the instance's private attribute `_config`.\n\n**[Output]**\n\n*  `self._config`: The configuration object itself. This object likely contains various key-value pairs or data structures representing the settings for the class instance. \n\n\nLet me know if you'd like a deeper dive into specific aspects of this code or have more snippets you'd like me to analyze!\n"
    },
    "quivr_core__llm__llm_endpoint__LLMEndpoint__supports_func_calling": {
        "label": "supports_func_calling",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/llm/llm_endpoint.py",
        "relativePath": "backend/core/quivr_core/llm/llm_endpoint.py",
        "lineNo": 59,
        "endLineNo": 61,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fllm%2Fllm_endpoint.py%23L59-L61&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis\n\n**Quick Summary:**\n\nThis function, named `self._supports_func_calling`,  returns a boolean value indicating whether a specific object or class supports function calling. This likely plays a role within a larger framework or library that needs to determine the callable nature of objects dynamically.\n\n**Inputs:**\n\n* **None:** The function does not explicitly take any arguments.\n\n**Output:**\n\n*  **Boolean (True/False):**  Indicates whether the object supports function calling. \n\n\n"
    },
    "quivr_core__models__SearchResult": {
        "label": "SearchResult",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/models.py",
        "relativePath": "backend/core/quivr_core/models.py",
        "lineNo": 97,
        "endLineNo": 99,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fmodels.py%23L97-L99&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Explanation:\n\n**Quick summary:** This code snippet likely defines a function to process and analyze a document, possibly for tasks like information retrieval or text summarization. It takes a document  and a distance value as input, suggesting it might involve calculating similarity or relevance based on this distance.\n\n**Inputs:**\n\n* **chunk:** A piece of text or data representing a section of the document.\n* **distance:** A numerical value potentially representing a measure of similarity, proximity, or relevance.\n\n**Output:**\n\n\nThe expected output is not provided in the code snippet. \n"
    },
    "quivr_core__processor__processor_base__ProcessorBase__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/processor_base.py",
        "relativePath": "backend/core/quivr_core/processor/processor_base.py",
        "lineNo": 23,
        "endLineNo": 25,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fprocessor_base.py%23L23-L25&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis: `raise NotImplementedError`\n\n**Quick Summary:** This function doesn't perform any action itself. It signals that a particular functionality is not yet implemented and should be handled later.  The `NotImplementedError` serves as a placeholder, indicating a missing code component.\n\n**Inputs:** None\n\n**Output:**  \n - Raises a `NotImplementedError` exception \n\n\nLet me know if you'd like a deeper explanation of exceptions or how to handle them in your code."
    },
    "quivr_core__processor__registr__available_processors": {
        "label": "available_processors",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/registry.py",
        "relativePath": "backend/core/quivr_core/processor/registry.py",
        "lineNo": 226,
        "endLineNo": 228,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fregistry.py%23L226-L228&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "```python\n    \"\"\"Return a list of the known processors.\"\"\"\n    return list(known_processors)\n```\n\n**[Quick Summary]**  This function retrieves and returns a list containing all the recognized processors. It's likely part of a larger system for managing or identifying available processing units.\n\n**[Inputs]**\n\n\n*  `known_processors`: This is likely a set or iterable containing processor names or identifiers. \n\n**[Output]**\n\n\n* A list of processor names or identifiers. \n\n\n"
    },
    "quivr_core__processor__splitter__SplitterConfig": {
        "label": "SplitterConfig",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/splitter.py",
        "relativePath": "backend/core/quivr_core/processor/splitter.py",
        "lineNo": 4,
        "endLineNo": 6,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fsplitter.py%23L4-L6&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Summary:\n\nThis code likely defines settings for a function that processes data in chunks. The function is probably designed to handle large datasets by dividing them into smaller, manageable pieces and potentially overlapping these chunks for better context. \n\n## Inputs:\n\n*  `chunk_size`: This integer value determines the size of each data chunk.\n*  `chunk_overlap`: This integer value represents the amount of data that overlaps between consecutive chunks.\n\n## Output:\n\n*  The function is designed to process data, not produce a direct output value.  \n* It will likely return some results based on the analysis performed on the data chunks.  \n\n\nLet me know if you have any other code snippets you'd like me to analyze! \n"
    },
    "quivr_core__quivr_rag__QuivrQARAG__retriever": {
        "label": "retriever",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/quivr_rag.py",
        "relativePath": "backend/core/quivr_core/quivr_rag.py",
        "lineNo": 62,
        "endLineNo": 64,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fquivr_rag.py%23L62-L64&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down this function snippet.\n\n**Quick Summary:**\n\nThis function likely belongs to a class managing a vector store (a database optimized for storing and searching vectors). It converts the internal vector store into a format suitable for use with a vector search retriever.  This retrieval mechanism would then be used to find documents or information similar to a given input query. The purpose is to facilitate efficient search and retrieval tasks based on semantic similarity.\n\n**Inputs:**\n\n*  `self.vector_store`: This refers to an instance variable within the class, which likely holds the vector data structure.\n\n**Output:**\n\n*A vector search retriever object* (likely an instance of a class designed for retrieving items from a vector store). \n\n\n\nLet me know if you'd like me to delve deeper into specific vector search algorithms or libraries!\n"
    },
    "quivr_core__storage__local_storage__LocalStorage__get_files": {
        "label": "get_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 54,
        "endLineNo": 56,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L54-L56&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's analyze the code snippet `return self.files`.\n\n**[Quick Summary]**\n\nThis function likely retrieves a list of files stored within an object (indicated by `self`) and returns that list. Its purpose is likely to provide access to the collection of files managed by this object.\n\n**[Inputs]**\n\n* `self`: This refers to the object itself, suggesting the function is a method within a class.\n\n**[Output]**\n\n*  `self.files`: A list of files associated with the object. \n"
    },
    "quivr_core__storage__local_storage__LocalStorage__info": {
        "label": "info",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 34,
        "endLineNo": 36,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L34-L36&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[Quick Summary]\nThis function likely returns a dictionary with information about a directory. It includes the absolute path to the directory (`directory_path`) and additional meta-data obtained from a parent class (`super().info()`).  The purpose is to provide a structured way to represent directory details. \n\n[Inputs]\n* `self:`  A reference to the current instance of the class.\n\n[Output]\n*  `directory_path`: A string representing the absolute path of the directory.\n*  Additional key-value pairs  from `super().info()`, which likely contain other directory-related information. \n\n\n"
    },
    "quivr_core__storage__local_storage__LocalStorage__nb_files": {
        "label": "nb_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 31,
        "endLineNo": 33,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L31-L33&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "[**Quick summary**]\n\nThis function likely belongs to a class that manages a collection of files.  It returns the number of files currently stored within the object. The purpose is to provide a way to determine the size of the file collection.  \n\n[**Inputs**]\n\n*  There are no explicit inputs listed for this function. \n* It likely relies on an internal attribute called \"files\" which holds the file objects or file names.\n\n[**Output**]\n\n* An integer representing the total count of files within the \"files\" attribute.   \n\n\n\nLet me know if you have any other code snippets you'd like me to analyze! \n"
    },
    "quivr_core__storage__local_storage__TransparentStorage____init__": {
        "label": "__init__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 66,
        "endLineNo": 68,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L66-L68&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary:\n\nThis code snippet initializes an empty dictionary called `id_files`.  This dictionary likely stores associations between unique identifiers (IDs) and file paths or other file-related information. The purpose is to manage and retrieve file data efficiently based on these IDs.\n\n## Inputs:\n\n- None. This is an initialization statement, not a function call.\n\n## Output:\n\n- A dictionary named `id_files` containing no key-value pairs.\n"
    },
    "quivr_core__storage__local_storage__TransparentStorage__nb_files": {
        "label": "nb_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 72,
        "endLineNo": 74,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L72-L74&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "##  Code Function Breakdown\n\n**[Quick Summary]** \n\nThis function, likely part of a larger class, returns the number of files stored within a collection identified as \"id_files\". Its purpose is to provide a count of the files managed by this object.\n\n\n**[Inputs]**\n\n*  `self`: A reference to the current instance of the class.\n\n**[Output]**\n\n* An integer representing the number of files in the \"id_files\" collection.  \n"
    },
    "quivr_core__storage__local_storage__TransparentStorage__remove_file": {
        "label": "remove_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 75,
        "endLineNo": 77,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L75-L77&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "You provided just a single line of code: \n\n```python\n        raise NotImplementedError\n```\n\nHere's the breakdown you requested:\n\n**[Quick Summary]**\n\nThis function is incomplete and intentionally halts its execution, signaling that a specific functionality is not yet implemented. It serves as a placeholder, indicating where development needs to occur.\n\n**[Inputs]**\n\n*  None \n\n**[Output]**\n\n*  `NotImplementedError` exception  is raised.   \n\n\n\nLet me know if you'd like me to elaborate on any of these points.\n"
    },
    "quivr_core__storage__local_storage__TransparentStorage__upload_file": {
        "label": "upload_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 69,
        "endLineNo": 71,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L69-L71&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**Quick Summary:**  This line of code is likely part of a larger program managing files. It stores information about a file, identified by a unique `id`, within a dictionary called `self.id_files`. This dictionary likely serves as a lookup table for quickly accessing file details based on their identifier.\n\n**Inputs:**\n\n* `file`: An object representing a file, containing information such as name, path, size, etc.\n* `file.id`: A unique identifier associated with the file.\n\n**Output:**\n\n* The `self.id_files` dictionary is updated with a new entry.\n* The key for this entry is `file.id`, and the value is the `file` object itself. \n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase____repr__": {
        "label": "__repr__",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 19,
        "endLineNo": 21,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L19-L21&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function likely returns a string representing the storage type associated with a given object. It accesses an attribute named \"name\" within the object to construct the output string.  The purpose appears to be providing information about the type of storage used.\n\n## Inputs\n\n*  `self`: This refers to the instance of the class the function belongs to. It likely contains information about the storage type.\n\n## Output\n\n*  A string in the format \"storage_type: <storage_type_name>\". \n    * `<storage_type_name>` will be the value of the `self.name` attribute. \n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase__get_files": {
        "label": "get_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 27,
        "endLineNo": 29,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L27-L29&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n[Quick summary]\nThis function appears to be designed to retrieve a list of files. However, it is currently incomplete as it raises an exception indicating that the `get_files` method is not implemented.\n\n## Inputs\nThis function does not have any defined inputs at the moment.\n\n## Output \n* An `Exception` is raised. \n* The exception message is \"Unimplemented get_files method\". \n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase__nb_files": {
        "label": "nb_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 23,
        "endLineNo": 25,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L23-L25&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Here's a breakdown of the code snippet:\n\n**Quick Summary**\n\nThis function is designed to retrieve the number of files within a directory but  currently lacks the implementation to do so.  The  `raise Exception`  statement indicates that this functionality needs to be added before the code can be used.\n\n**Inputs**\n\n*  None are explicitly defined. The function likely expects to operate on a directory path, either passed as an argument or implicitly accessed. \n\n**Output**\n\n*  None, or an exception  (`Exception(\"Unimplemented nb_files method\")`) would be raised. \n\n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase__remove_file": {
        "label": "remove_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 35,
        "endLineNo": 37,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L35-L37&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis\n\n**[Quick Summary]**  \nThis code defines a method (likely within a class) intended to remove a file. However, it's currently not functional and throws an exception indicating the method hasn't been implemented yet. The purpose is to signal that this functionality is planned but not yet available. \n\n**[Inputs]**\n* \n  None explicitly mentioned, but the method name suggests it might take the file's path or name as input. \n\n**[Output]**\n*  An exception of type 'Exception' is raised with the message \"Unimplemented remove_file method\". \n\n\n\n"
    },
    "quivr_core__storage__storage_base__StorageBase__upload_file": {
        "label": "upload_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/storage_base.py",
        "relativePath": "backend/core/quivr_core/storage/storage_base.py",
        "lineNo": 31,
        "endLineNo": 33,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Fstorage_base.py%23L31-L33&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Summary\n\nThis function likely defines a method for uploading a file but currently lacks implementation. The code is highlighting this missing functionality by raising an \"Unimplemented\" exception. \n\n## Inputs\n\n*  Implicit input: A file to be uploaded.\n\n## Output\n\n*  Raises an exception: \"Exception(\"Unimplemented upload_file method\")\" \n\n\n"
    },
    "tests__processor__test_registr__test_register_new_proc__TestProcessor__process_file": {
        "label": "process_file",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 174,
        "endLineNo": 176,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L174-L176&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis \n\n**Quick Summary**\nThis function returns an empty list (`[]`). Its purpose is likely to provide a default, empty collection when no specific data needs to be returned. \n\n**Inputs** \n* There are no explicit inputs defined in the code snippet.\n\n**Output**\n* An empty list: `[]` \n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "tests__processor__test_registr__test_register_non_processor__NOTPROC": {
        "label": "NOTPROC",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 185,
        "endLineNo": 187,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L185-L187&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Quick Summary\n\nThis code snippet defines a list named `supported_extensions` containing a single element, \".pdf\". This likely signifies the function's purpose is to determine if a given file should be processed based on its extension matching a specific set of allowed types, primarily focusing on PDF files.\n\n## Inputs\n\n* `supported_extensions`: A list of strings representing allowed file extensions.\n\n## Output\n\n* Not explicitly defined. Likely a boolean value (True/False) indicating whether the input file extension is allowed based on the `supported_extensions` list. \n\n\n"
    },
    "tests__processor__test_registr__test_register_override_error__TestProcessor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 219,
        "endLineNo": 221,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L219-L221&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Breakdown \n\n**Quick Summary:** This function seems designed to handle some sort of data retrieval or processing, but in its current state, it always returns an empty list. The purpose remains unclear without further context.  \n\n**Inputs:**\n\n*  There are no explicit inputs defined within the provided code snippet. \n\n**Output:**\n* An empty list (`[]`). \n\n\nLet me know if you have more code or context!  A single line like `return []` can have many interpretations depending on where it sits within a larger program.  \n"
    },
    "tests__processor__test_registr__test_register_override_error__TestProcessor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 216,
        "endLineNo": 218,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L216-L218&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis:\n\n**Quick Summary:**\n\nThis function likely aims to demonstrate a simple return statement in programming. It returns an empty dictionary, potentially as a placeholder or to indicate the absence of data.\n\n**Inputs:**\n\n*  There are no explicit inputs defined for this function.\n\n**Output:**\n\n*  An empty dictionary: `{}`  \n"
    },
    "tests__processor__test_registr__test_register_override_proc__TestProcessor__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 200,
        "endLineNo": 202,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L200-L202&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "```python\n         return []\n```\n\n[Quick summary] This function defines a simple Python function that returns an empty list.  The purpose of this code is likely to provide a placeholder or simply return an empty collection when no specific data is needed.\n\n[Inputs]\n*  There are no explicit inputs defined for this function.\n\n[Output]\n*  An empty list  `[]` \n"
    },
    "tests__processor__test_registr__test_register_override_proc__TestProcessor__processor_metadata": {
        "label": "processor_metadata",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 197,
        "endLineNo": 199,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L197-L199&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "```python\n            return {} \n```\n\n**Quick Summary**\nThis function returns an empty dictionary. Its purpose is likely to provide a way to initialize a dictionary or return an empty result when no meaningful data exists.\n\n**Inputs** \n\n*  There are no explicit inputs to this function.\n\n **Output** \n\n* An empty dictionary: `{}`  \n"
    },
    "tests__test_quivr_rag__mock_chain_qa_stream__mock_qa_chain": {
        "label": "mock_qa_chain",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/test_quivr_rag.py",
        "relativePath": "backend/core/tests/test_quivr_rag.py",
        "lineNo": 18,
        "endLineNo": 20,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Ftest_quivr_rag.py%23L18-L20&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Function Analysis \n\n**[Quick Summary]**\nThis Python function simply returns an instance of a custom class named `MockQAChain`. The purpose of this code is likely to create a simulated or test version of a Question Answering (QA) Chain for development or testing purposes.  \n\n\n**[Inputs]**\n*  None - The function takes no explicit inputs.\n\n**[Output]**\n*  An instance of the `MockQAChain` class. \n\n\n\n\nLet me know if you have any other code snippets you'd like me to analyze! \n"
    },
    "quivr_core__processor__processor_base__ProcessorBase__process_file_inner": {
        "label": "process_file_inner",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/processor/processor_base.py",
        "relativePath": "backend/core/quivr_core/processor/processor_base.py",
        "lineNo": 46,
        "endLineNo": 47,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fprocessor%2Fprocessor_base.py%23L46-L47&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "**[Quick summary]**\n\nThis Python function is designed to be a placeholder for functionality that hasn't been implemented yet.  The `NotImplementedError` signals that this part of the code requires further development before it can function correctly.  It essentially acts as a marker for future work.\n\n**[Inputs]**\n\n*  None -  as there are no arguments to the function.\n\n**[Output]**\n\n\n*  Raises a `NotImplementedError` Exception. \n"
    },
    "quivr_core__storage__local_storage__TransparentStorage__get_files": {
        "label": "get_files",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/quivr_core/storage/local_storage.py",
        "relativePath": "backend/core/quivr_core/storage/local_storage.py",
        "lineNo": 78,
        "endLineNo": 79,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Fquivr_core%2Fstorage%2Flocal_storage.py%23L78-L79&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Code Analysis:\n\n**[Quick Summary]** This function likely retrieves a list of all file IDs associated with an object (presumably a class).  It appears to be part of a system that manages files, possibly by ID. \n\n**[Inputs]**\n\n* `self.id_files`: This is likely a dictionary where keys are file IDs and values are corresponding file information.\n\n**[Output]** \n\n* A list containing all the file IDs present in the `self.id_files` dictionary. \n\n\n"
    },
    "tests__conftest__mem_vector_store": {
        "label": "mem_vector_store",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/conftest.py",
        "relativePath": "backend/core/tests/conftest.py",
        "lineNo": 91,
        "endLineNo": 92,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fconftest.py%23L91-L92&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "## Analysis of Code Snippet: \n\n**[Quick summary]** This function creates and returns an in-memory vector store. It utilizes an `embedder` object to transform text into numerical vector representations, which are then stored and indexed in memory for efficient retrieval.  This is commonly used in semantic search applications.\n\n**[Inputs]**\n* `embedder`: This is likely an object responsible for generating vector embeddings from textual input.\n\n**[Output]**\n* An instance of `InMemoryVectorStore`, a data structure designed to store and retrieve vector embeddings in memory. \n\n\nLet me know if you have any other code snippets you'd like me to analyze!\n"
    },
    "tests__processor__test_registr__test_available_processors": {
        "label": "test_available_processors",
        "systemPath": "/home/sanjay/Development/explore/quivr/backend/core/tests/processor/test_registry.py",
        "relativePath": "backend/core/tests/processor/test_registry.py",
        "lineNo": 226,
        "endLineNo": 227,
        "emgithubIframeLink": "https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2FQuivrHQ%2Fquivr%2Fblob%2Fmain%2Fbackend%2Fcore%2Ftests%2Fprocessor%2Ftest_registry.py%23L226-L227&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on",
        "description": "Let's break down your code snippet. \n\n**[Quick Summary]**\n\nThis code snippet is designed to check the number of available processors on a system. The `available_processors()` function likely retrieves this information, and the `assert` statement verifies that the returned count is exactly 17. This suggests a specific expectation about the system's hardware configuration.\n\n**[Inputs]**\n\n*  None explicitly stated. It likely relies on system-level information.\n\n**[Output]**\n\n* **Expected:** No explicit output is generated. \n* **Implicit:** Success or failure of the assertion (`True` or `False`). An assertion failure would indicate an issue with the hardware configuration or the `available_processors()` function. \n\n\n\nLet me know if you have any other code snippets you'd like me to analyze!"
    }
}